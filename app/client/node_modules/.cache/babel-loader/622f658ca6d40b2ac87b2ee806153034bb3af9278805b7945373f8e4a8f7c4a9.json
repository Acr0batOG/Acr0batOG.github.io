{"ast":null,"code":"/**\n * @author      Created by Marcus Spiegel <spiegel@uscreen.de> on 2011-03-25.\n * @link        https://github.com/mashpie/i18n-node\n * @license     http://opensource.org/licenses/MIT\n */\n\n'use strict';\n\n// dependencies\nconst printf = require('fast-printf').printf;\nconst pkgVersion = require('./package.json').version;\nconst fs = require('fs');\nconst url = require('url');\nconst path = require('path');\nconst debug = require('debug')('i18n:debug');\nconst warn = require('debug')('i18n:warn');\nconst error = require('debug')('i18n:error');\nconst Mustache = require('mustache');\nconst Messageformat = require('@messageformat/core');\nconst MakePlural = require('make-plural');\nconst parseInterval = require('math-interval-parser').default;\n\n// utils\nconst escapeRegExp = string => string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n\n/**\n * create constructor function\n */\nconst i18n = function I18n(_OPTS = false) {\n  const MessageformatInstanceForLocale = {};\n  const PluralsForLocale = {};\n  let locales = {};\n  const api = {\n    __: '__',\n    __n: '__n',\n    __l: '__l',\n    __h: '__h',\n    __mf: '__mf',\n    getLocale: 'getLocale',\n    setLocale: 'setLocale',\n    getCatalog: 'getCatalog',\n    getLocales: 'getLocales',\n    addLocale: 'addLocale',\n    removeLocale: 'removeLocale'\n  };\n  const mustacheConfig = {\n    tags: ['{{', '}}'],\n    disable: false\n  };\n  let mustacheRegex;\n  const pathsep = path.sep; // ---> means win support will be available in node 0.8.x and above\n  let autoReload;\n  let cookiename;\n  let languageHeaderName;\n  let defaultLocale;\n  let retryInDefaultLocale;\n  let directory;\n  let directoryPermissions;\n  let extension;\n  let fallbacks;\n  let indent;\n  let logDebugFn;\n  let logErrorFn;\n  let logWarnFn;\n  let preserveLegacyCase;\n  let objectNotation;\n  let prefix;\n  let queryParameter;\n  let register;\n  let updateFiles;\n  let syncFiles;\n  let missingKeyFn;\n  let parser;\n\n  // public exports\n  const i18n = {};\n  i18n.version = pkgVersion;\n  i18n.configure = function i18nConfigure(opt) {\n    // reset locales\n    locales = {};\n\n    // Provide custom API method aliases if desired\n    // This needs to be processed before the first call to applyAPItoObject()\n    if (opt.api && typeof opt.api === 'object') {\n      for (const method in opt.api) {\n        if (Object.prototype.hasOwnProperty.call(opt.api, method)) {\n          const alias = opt.api[method];\n          if (typeof api[method] !== 'undefined') {\n            api[method] = alias;\n          }\n        }\n      }\n    }\n\n    // you may register i18n in global scope, up to you\n    if (typeof opt.register === 'object') {\n      register = opt.register;\n      // or give an array objects to register to\n      if (Array.isArray(opt.register)) {\n        register = opt.register;\n        register.forEach(applyAPItoObject);\n      } else {\n        applyAPItoObject(opt.register);\n      }\n    }\n\n    // sets a custom cookie name to parse locale settings from\n    cookiename = typeof opt.cookie === 'string' ? opt.cookie : null;\n\n    // set the custom header name to extract the language locale\n    languageHeaderName = typeof opt.header === 'string' ? opt.header : 'accept-language';\n\n    // query-string parameter to be watched - @todo: add test & doc\n    queryParameter = typeof opt.queryParameter === 'string' ? opt.queryParameter : null;\n\n    // where to store json files\n    directory = typeof opt.directory === 'string' ? opt.directory : path.join(__dirname, 'locales');\n\n    // permissions when creating new directories\n    directoryPermissions = typeof opt.directoryPermissions === 'string' ? parseInt(opt.directoryPermissions, 8) : null;\n\n    // write new locale information to disk\n    updateFiles = typeof opt.updateFiles === 'boolean' ? opt.updateFiles : true;\n\n    // sync locale information accros all files\n    syncFiles = typeof opt.syncFiles === 'boolean' ? opt.syncFiles : false;\n\n    // what to use as the indentation unit (ex: \"\\t\", \"  \")\n    indent = typeof opt.indent === 'string' ? opt.indent : '\\t';\n\n    // json files prefix\n    prefix = typeof opt.prefix === 'string' ? opt.prefix : '';\n\n    // where to store json files\n    extension = typeof opt.extension === 'string' ? opt.extension : '.json';\n\n    // setting defaultLocale\n    defaultLocale = typeof opt.defaultLocale === 'string' ? opt.defaultLocale : 'en';\n\n    // allow to retry in default locale, useful for production\n    retryInDefaultLocale = typeof opt.retryInDefaultLocale === 'boolean' ? opt.retryInDefaultLocale : false;\n\n    // auto reload locale files when changed\n    autoReload = typeof opt.autoReload === 'boolean' ? opt.autoReload : false;\n\n    // enable object notation?\n    objectNotation = typeof opt.objectNotation !== 'undefined' ? opt.objectNotation : false;\n    if (objectNotation === true) objectNotation = '.';\n\n    // read language fallback map\n    fallbacks = typeof opt.fallbacks === 'object' ? opt.fallbacks : {};\n\n    // setting custom logger functions\n    logDebugFn = typeof opt.logDebugFn === 'function' ? opt.logDebugFn : debug;\n    logWarnFn = typeof opt.logWarnFn === 'function' ? opt.logWarnFn : warn;\n    logErrorFn = typeof opt.logErrorFn === 'function' ? opt.logErrorFn : error;\n    preserveLegacyCase = typeof opt.preserveLegacyCase === 'boolean' ? opt.preserveLegacyCase : true;\n\n    // setting custom missing key function\n    missingKeyFn = typeof opt.missingKeyFn === 'function' ? opt.missingKeyFn : missingKey;\n    parser = typeof opt.parser === 'object' && typeof opt.parser.parse === 'function' && typeof opt.parser.stringify === 'function' ? opt.parser : JSON;\n\n    // when missing locales we try to guess that from directory\n    opt.locales = opt.staticCatalog ? Object.keys(opt.staticCatalog) : opt.locales || guessLocales(directory);\n\n    // some options should be disabled when using staticCatalog\n    if (opt.staticCatalog) {\n      updateFiles = false;\n      autoReload = false;\n      syncFiles = false;\n    }\n\n    // customize mustache parsing\n    if (opt.mustacheConfig) {\n      if (Array.isArray(opt.mustacheConfig.tags)) {\n        mustacheConfig.tags = opt.mustacheConfig.tags;\n      }\n      if (opt.mustacheConfig.disable === true) {\n        mustacheConfig.disable = true;\n      }\n    }\n    const [start, end] = mustacheConfig.tags;\n    mustacheRegex = new RegExp(escapeRegExp(start) + '.*' + escapeRegExp(end));\n\n    // implicitly read all locales\n    if (Array.isArray(opt.locales)) {\n      if (opt.staticCatalog) {\n        locales = opt.staticCatalog;\n      } else {\n        opt.locales.forEach(read);\n      }\n\n      // auto reload locale files when changed\n      if (autoReload) {\n        // watch changes of locale files (it's called twice because fs.watch is still unstable)\n        fs.watch(directory, (event, filename) => {\n          const localeFromFile = guessLocaleFromFile(filename);\n          if (localeFromFile && opt.locales.indexOf(localeFromFile) > -1) {\n            logDebug('Auto reloading locale file \"' + filename + '\".');\n            read(localeFromFile);\n          }\n        });\n      }\n    }\n  };\n  i18n.init = function i18nInit(request, response, next) {\n    if (typeof request === 'object') {\n      // guess requested language/locale\n      guessLanguage(request);\n\n      // bind api to req\n      applyAPItoObject(request);\n\n      // looks double but will ensure schema on api refactor\n      i18n.setLocale(request, request.locale);\n    } else {\n      return logError('i18n.init must be called with one parameter minimum, ie. i18n.init(req)');\n    }\n    if (typeof response === 'object') {\n      applyAPItoObject(response);\n\n      // and set that locale to response too\n      i18n.setLocale(response, request.locale);\n    }\n\n    // head over to next callback when bound as middleware\n    if (typeof next === 'function') {\n      return next();\n    }\n  };\n  i18n.__ = function i18nTranslate(phrase) {\n    let msg;\n    const argv = parseArgv(arguments);\n    const namedValues = argv[0];\n    const args = argv[1];\n\n    // called like __({phrase: \"Hello\", locale: \"en\"})\n    if (typeof phrase === 'object') {\n      if (typeof phrase.locale === 'string' && typeof phrase.phrase === 'string') {\n        msg = translate(phrase.locale, phrase.phrase);\n      }\n    }\n    // called like __(\"Hello\")\n    else {\n      // get translated message with locale from scope (deprecated) or object\n      msg = translate(getLocaleFromObject(this), phrase);\n    }\n\n    // postprocess to get compatible to plurals\n    if (typeof msg === 'object' && msg.one) {\n      msg = msg.one;\n    }\n\n    // in case there is no 'one' but an 'other' rule\n    if (typeof msg === 'object' && msg.other) {\n      msg = msg.other;\n    }\n\n    // head over to postProcessing\n    return postProcess(msg, namedValues, args);\n  };\n  i18n.__mf = function i18nMessageformat(phrase) {\n    let msg, mf, f;\n    let targetLocale = defaultLocale;\n    const argv = parseArgv(arguments);\n    const namedValues = argv[0];\n    const args = argv[1];\n\n    // called like __({phrase: \"Hello\", locale: \"en\"})\n    if (typeof phrase === 'object') {\n      if (typeof phrase.locale === 'string' && typeof phrase.phrase === 'string') {\n        msg = phrase.phrase;\n        targetLocale = phrase.locale;\n      }\n    }\n    // called like __(\"Hello\")\n    else {\n      // get translated message with locale from scope (deprecated) or object\n      msg = phrase;\n      targetLocale = getLocaleFromObject(this);\n    }\n    msg = translate(targetLocale, msg);\n    // --- end get msg\n\n    // now head over to Messageformat\n    // and try to cache instance\n    if (MessageformatInstanceForLocale[targetLocale]) {\n      mf = MessageformatInstanceForLocale[targetLocale];\n    } else {\n      mf = new Messageformat(targetLocale);\n      mf.compiledFunctions = {};\n      MessageformatInstanceForLocale[targetLocale] = mf;\n    }\n\n    // let's try to cache that function\n    if (mf.compiledFunctions[msg]) {\n      f = mf.compiledFunctions[msg];\n    } else {\n      f = mf.compile(msg);\n      mf.compiledFunctions[msg] = f;\n    }\n    return postProcess(f(namedValues), namedValues, args);\n  };\n  i18n.__l = function i18nTranslationList(phrase) {\n    const translations = [];\n    Object.keys(locales).sort().forEach(l => {\n      translations.push(i18n.__({\n        phrase: phrase,\n        locale: l\n      }));\n    });\n    return translations;\n  };\n  i18n.__h = function i18nTranslationHash(phrase) {\n    const translations = [];\n    Object.keys(locales).sort().forEach(l => {\n      const hash = {};\n      hash[l] = i18n.__({\n        phrase: phrase,\n        locale: l\n      });\n      translations.push(hash);\n    });\n    return translations;\n  };\n  i18n.__n = function i18nTranslatePlural(singular, plural, count) {\n    let msg;\n    let namedValues;\n    let targetLocale;\n    let args = [];\n\n    // Accept an object with named values as the last parameter\n    if (argsEndWithNamedObject(arguments)) {\n      namedValues = arguments[arguments.length - 1];\n      args = arguments.length >= 5 ? Array.prototype.slice.call(arguments, 3, -1) : [];\n    } else {\n      namedValues = {};\n      args = arguments.length >= 4 ? Array.prototype.slice.call(arguments, 3) : [];\n    }\n\n    // called like __n({singular: \"%s cat\", plural: \"%s cats\", locale: \"en\"}, 3)\n    if (typeof singular === 'object') {\n      if (typeof singular.locale === 'string' && typeof singular.singular === 'string' && typeof singular.plural === 'string') {\n        targetLocale = singular.locale;\n        msg = translate(singular.locale, singular.singular, singular.plural);\n      }\n      args.unshift(count);\n\n      // some template engines pass all values as strings -> so we try to convert them to numbers\n      if (typeof plural === 'number' || Number(plural) + '' === plural) {\n        count = plural;\n      }\n\n      // called like __n({singular: \"%s cat\", plural: \"%s cats\", locale: \"en\", count: 3})\n      if (typeof singular.count === 'number' || typeof singular.count === 'string') {\n        count = singular.count;\n        args.unshift(plural);\n      }\n    } else {\n      // called like  __n('cat', 3)\n      if (typeof plural === 'number' || Number(plural) + '' === plural) {\n        count = plural;\n\n        // we add same string as default\n        // which efectivly copies the key to the plural.value\n        // this is for initialization of new empty translations\n        plural = singular;\n        args.unshift(count);\n        args.unshift(plural);\n      }\n      // called like __n('%s cat', '%s cats', 3)\n      // get translated message with locale from scope (deprecated) or object\n      msg = translate(getLocaleFromObject(this), singular, plural);\n      targetLocale = getLocaleFromObject(this);\n    }\n    if (count === null) count = namedValues.count;\n\n    // enforce number\n    count = Number(count);\n\n    // find the correct plural rule for given locale\n    if (typeof msg === 'object') {\n      let p;\n      // create a new Plural for locale\n      // and try to cache instance\n      if (PluralsForLocale[targetLocale]) {\n        p = PluralsForLocale[targetLocale];\n      } else {\n        // split locales with a region code\n        const lc = targetLocale.toLowerCase().split(/[_-\\s]+/).filter(el => true && el);\n        // take the first part of locale, fallback to full locale\n        p = MakePlural[lc[0] || targetLocale];\n        PluralsForLocale[targetLocale] = p;\n      }\n\n      // fallback to 'other' on case of missing translations\n      msg = msg[p(count)] || msg.other;\n    }\n\n    // head over to postProcessing\n    return postProcess(msg, namedValues, args, count);\n  };\n  i18n.setLocale = function i18nSetLocale(object, locale, skipImplicitObjects) {\n    // when given an array of objects => setLocale on each\n    if (Array.isArray(object) && typeof locale === 'string') {\n      for (let i = object.length - 1; i >= 0; i--) {\n        i18n.setLocale(object[i], locale, true);\n      }\n      return i18n.getLocale(object[0]);\n    }\n\n    // defaults to called like i18n.setLocale(req, 'en')\n    let targetObject = object;\n    let targetLocale = locale;\n\n    // called like req.setLocale('en') or i18n.setLocale('en')\n    if (locale === undefined && typeof object === 'string') {\n      targetObject = this;\n      targetLocale = object;\n    }\n\n    // consider a fallback\n    if (!locales[targetLocale]) {\n      targetLocale = getFallback(targetLocale, fallbacks) || targetLocale;\n    }\n\n    // now set locale on object\n    targetObject.locale = locales[targetLocale] ? targetLocale : defaultLocale;\n\n    // consider any extra registered objects\n    if (typeof register === 'object') {\n      if (Array.isArray(register) && !skipImplicitObjects) {\n        register.forEach(r => {\n          r.locale = targetObject.locale;\n        });\n      } else {\n        register.locale = targetObject.locale;\n      }\n    }\n\n    // consider res\n    if (targetObject.res && !skipImplicitObjects) {\n      // escape recursion\n      // @see  - https://github.com/balderdashy/sails/pull/3631\n      //       - https://github.com/mashpie/i18n-node/pull/218\n      if (targetObject.res.locals) {\n        i18n.setLocale(targetObject.res, targetObject.locale, true);\n        i18n.setLocale(targetObject.res.locals, targetObject.locale, true);\n      } else {\n        i18n.setLocale(targetObject.res, targetObject.locale);\n      }\n    }\n\n    // consider locals\n    if (targetObject.locals && !skipImplicitObjects) {\n      // escape recursion\n      // @see  - https://github.com/balderdashy/sails/pull/3631\n      //       - https://github.com/mashpie/i18n-node/pull/218\n      if (targetObject.locals.res) {\n        i18n.setLocale(targetObject.locals, targetObject.locale, true);\n        i18n.setLocale(targetObject.locals.res, targetObject.locale, true);\n      } else {\n        i18n.setLocale(targetObject.locals, targetObject.locale);\n      }\n    }\n    return i18n.getLocale(targetObject);\n  };\n  i18n.getLocale = function i18nGetLocale(request) {\n    // called like i18n.getLocale(req)\n    if (request && request.locale) {\n      return request.locale;\n    }\n\n    // called like req.getLocale()\n    return this.locale || defaultLocale;\n  };\n  i18n.getCatalog = function i18nGetCatalog(object, locale) {\n    let targetLocale;\n\n    // called like i18n.getCatalog(req)\n    if (typeof object === 'object' && typeof object.locale === 'string' && locale === undefined) {\n      targetLocale = object.locale;\n    }\n\n    // called like i18n.getCatalog(req, 'en')\n    if (!targetLocale && typeof object === 'object' && typeof locale === 'string') {\n      targetLocale = locale;\n    }\n\n    // called like req.getCatalog('en')\n    if (!targetLocale && locale === undefined && typeof object === 'string') {\n      targetLocale = object;\n    }\n\n    // called like req.getCatalog()\n    if (!targetLocale && object === undefined && locale === undefined && typeof this.locale === 'string') {\n      if (register && register.global) {\n        targetLocale = '';\n      } else {\n        targetLocale = this.locale;\n      }\n    }\n\n    // called like i18n.getCatalog()\n    if (targetLocale === undefined || targetLocale === '') {\n      return locales;\n    }\n    if (!locales[targetLocale]) {\n      targetLocale = getFallback(targetLocale, fallbacks) || targetLocale;\n    }\n    if (locales[targetLocale]) {\n      return locales[targetLocale];\n    } else {\n      logWarn('No catalog found for \"' + targetLocale + '\"');\n      return false;\n    }\n  };\n  i18n.getLocales = function i18nGetLocales() {\n    return Object.keys(locales);\n  };\n  i18n.addLocale = function i18nAddLocale(locale) {\n    read(locale);\n  };\n  i18n.removeLocale = function i18nRemoveLocale(locale) {\n    delete locales[locale];\n  };\n\n  // ===================\n  // = private methods =\n  // ===================\n\n  const postProcess = (msg, namedValues, args, count) => {\n    // test for parsable interval string\n    if (/\\|/.test(msg)) {\n      msg = parsePluralInterval(msg, count);\n    }\n\n    // replace the counter\n    if (typeof count === 'number') {\n      msg = printf(msg, Number(count));\n    }\n\n    // if the msg string contains {{Mustache}} patterns we render it as a mini template\n    if (!mustacheConfig.disable && mustacheRegex.test(msg)) {\n      msg = Mustache.render(msg, namedValues, {}, mustacheConfig.tags);\n    }\n\n    // if we have extra arguments with values to get replaced,\n    // an additional substition injects those strings afterwards\n    if (/%/.test(msg) && args && args.length > 0) {\n      msg = printf(msg, ...args);\n    }\n    return msg;\n  };\n  const argsEndWithNamedObject = args => args.length > 1 && args[args.length - 1] !== null && typeof args[args.length - 1] === 'object';\n  const parseArgv = args => {\n    let namedValues, returnArgs;\n    if (argsEndWithNamedObject(args)) {\n      namedValues = args[args.length - 1];\n      returnArgs = Array.prototype.slice.call(args, 1, -1);\n    } else {\n      namedValues = {};\n      returnArgs = args.length >= 2 ? Array.prototype.slice.call(args, 1) : [];\n    }\n    return [namedValues, returnArgs];\n  };\n\n  /**\n   * registers all public API methods to a given response object when not already declared\n   */\n  const applyAPItoObject = object => {\n    let alreadySetted = true;\n\n    // attach to itself if not provided\n    for (const method in api) {\n      if (Object.prototype.hasOwnProperty.call(api, method)) {\n        const alias = api[method];\n\n        // be kind rewind, or better not touch anything already existing\n        if (!object[alias]) {\n          alreadySetted = false;\n          object[alias] = i18n[method].bind(object);\n        }\n      }\n    }\n\n    // set initial locale if not set\n    if (!object.locale) {\n      object.locale = defaultLocale;\n    }\n\n    // escape recursion\n    if (alreadySetted) {\n      return;\n    }\n\n    // attach to response if present (ie. in express)\n    if (object.res) {\n      applyAPItoObject(object.res);\n    }\n\n    // attach to locals if present (ie. in express)\n    if (object.locals) {\n      applyAPItoObject(object.locals);\n    }\n  };\n\n  /**\n   * tries to guess locales by scanning the given directory\n   */\n  const guessLocales = directory => {\n    const entries = fs.readdirSync(directory);\n    const localesFound = [];\n    for (let i = entries.length - 1; i >= 0; i--) {\n      if (entries[i].match(/^\\./)) continue;\n      const localeFromFile = guessLocaleFromFile(entries[i]);\n      if (localeFromFile) localesFound.push(localeFromFile);\n    }\n    return localesFound.sort();\n  };\n\n  /**\n   * tries to guess locales from a given filename\n   */\n  const guessLocaleFromFile = filename => {\n    const extensionRegex = new RegExp(extension + '$', 'g');\n    const prefixRegex = new RegExp('^' + prefix, 'g');\n    if (!filename) return false;\n    if (prefix && !filename.match(prefixRegex)) return false;\n    if (extension && !filename.match(extensionRegex)) return false;\n    return filename.replace(prefix, '').replace(extensionRegex, '');\n  };\n\n  /**\n   * @param queryLanguage - language query parameter, either an array or a string.\n   * @return the first non-empty language query parameter found, null otherwise.\n   */\n  const extractQueryLanguage = queryLanguage => {\n    if (Array.isArray(queryLanguage)) {\n      return queryLanguage.find(lang => lang !== '' && lang);\n    }\n    return typeof queryLanguage === 'string' && queryLanguage;\n  };\n\n  /**\n   * guess language setting based on http headers\n   */\n\n  const guessLanguage = request => {\n    if (typeof request === 'object') {\n      const languageHeader = request.headers ? request.headers[languageHeaderName] : undefined;\n      const languages = [];\n      const regions = [];\n      request.languages = [defaultLocale];\n      request.regions = [defaultLocale];\n      request.language = defaultLocale;\n      request.region = defaultLocale;\n\n      // a query parameter overwrites all\n      if (queryParameter && request.url) {\n        const urlAsString = typeof request.url === 'string' ? request.url : request.url.toString();\n\n        /**\n         * @todo WHATWG new URL() requires full URL including hostname - that might change\n         * @see https://github.com/nodejs/node/issues/12682\n         */\n        // eslint-disable-next-line node/no-deprecated-api\n        const urlObj = url.parse(urlAsString, true);\n        const languageQueryParameter = urlObj.query[queryParameter];\n        if (languageQueryParameter) {\n          let queryLanguage = extractQueryLanguage(languageQueryParameter);\n          if (queryLanguage) {\n            logDebug('Overriding locale from query: ' + queryLanguage);\n            if (preserveLegacyCase) {\n              queryLanguage = queryLanguage.toLowerCase();\n            }\n            return i18n.setLocale(request, queryLanguage);\n          }\n        }\n      }\n\n      // a cookie overwrites headers\n      if (cookiename && request.cookies && request.cookies[cookiename]) {\n        request.language = request.cookies[cookiename];\n        return i18n.setLocale(request, request.language);\n      }\n\n      // 'accept-language' is the most common source\n      if (languageHeader) {\n        const acceptedLanguages = getAcceptedLanguagesFromHeader(languageHeader);\n        let match;\n        let fallbackMatch;\n        let fallback;\n        for (let i = 0; i < acceptedLanguages.length; i++) {\n          const lang = acceptedLanguages[i];\n          const lr = lang.split('-', 2);\n          const parentLang = lr[0];\n          const region = lr[1];\n\n          // Check if we have a configured fallback set for this language.\n          const fallbackLang = getFallback(lang, fallbacks);\n          if (fallbackLang) {\n            fallback = fallbackLang;\n            // Fallbacks for languages should be inserted\n            // where the original, unsupported language existed.\n            const acceptedLanguageIndex = acceptedLanguages.indexOf(lang);\n            const fallbackIndex = acceptedLanguages.indexOf(fallback);\n            if (fallbackIndex > -1) {\n              acceptedLanguages.splice(fallbackIndex, 1);\n            }\n            acceptedLanguages.splice(acceptedLanguageIndex + 1, 0, fallback);\n          }\n\n          // Check if we have a configured fallback set for the parent language of the locale.\n          const fallbackParentLang = getFallback(parentLang, fallbacks);\n          if (fallbackParentLang) {\n            fallback = fallbackParentLang;\n            // Fallbacks for a parent language should be inserted\n            // to the end of the list, so they're only picked\n            // if there is no better match.\n            if (acceptedLanguages.indexOf(fallback) < 0) {\n              acceptedLanguages.push(fallback);\n            }\n          }\n          if (languages.indexOf(parentLang) < 0) {\n            languages.push(parentLang.toLowerCase());\n          }\n          if (region) {\n            regions.push(region.toLowerCase());\n          }\n          if (!match && locales[lang]) {\n            match = lang;\n            break;\n          }\n          if (!fallbackMatch && locales[parentLang]) {\n            fallbackMatch = parentLang;\n          }\n        }\n        request.language = match || fallbackMatch || request.language;\n        request.region = regions[0] || request.region;\n        return i18n.setLocale(request, request.language);\n      }\n    }\n\n    // last resort: defaultLocale\n    return i18n.setLocale(request, defaultLocale);\n  };\n\n  /**\n   * Get a sorted list of accepted languages from the HTTP Accept-Language header\n   */\n  const getAcceptedLanguagesFromHeader = header => {\n    const languages = header.split(',');\n    const preferences = {};\n    return languages.map(item => {\n      const preferenceParts = item.trim().split(';q=');\n      if (preferenceParts.length < 2) {\n        preferenceParts[1] = 1.0;\n      } else {\n        const quality = parseFloat(preferenceParts[1]);\n        preferenceParts[1] = quality || 0.0;\n      }\n      preferences[preferenceParts[0]] = preferenceParts[1];\n      return preferenceParts[0];\n    }).filter(lang => preferences[lang] > 0).sort((a, b) => preferences[b] - preferences[a]);\n  };\n\n  /**\n   * searches for locale in given object\n   */\n\n  const getLocaleFromObject = obj => {\n    let locale;\n    if (obj && obj.scope) {\n      locale = obj.scope.locale;\n    }\n    if (obj && obj.locale) {\n      locale = obj.locale;\n    }\n    return locale;\n  };\n\n  /**\n   * splits and parses a phrase for mathematical interval expressions\n   */\n  const parsePluralInterval = (phrase, count) => {\n    let returnPhrase = phrase;\n    const phrases = phrase.split(/\\|/);\n    let intervalRuleExists = false;\n\n    // some() breaks on 1st true\n    phrases.some(p => {\n      const matches = p.match(/^\\s*([()[\\]]+[\\d,]+[()[\\]]+)?\\s*(.*)$/);\n\n      // not the same as in combined condition\n      if (matches != null && matches[1]) {\n        intervalRuleExists = true;\n        if (matchInterval(count, matches[1]) === true) {\n          returnPhrase = matches[2];\n          return true;\n        }\n      } else {\n        // this is a other or catch all case, this only is taken into account if there is actually another rule\n        if (intervalRuleExists) {\n          returnPhrase = p;\n        }\n      }\n      return false;\n    });\n    return returnPhrase;\n  };\n\n  /**\n   * test a number to match mathematical interval expressions\n   * [0,2] - 0 to 2 (including, matches: 0, 1, 2)\n   * ]0,3[ - 0 to 3 (excluding, matches: 1, 2)\n   * [1]   - 1 (matches: 1)\n   * [20,] - all numbers ≥20 (matches: 20, 21, 22, ...)\n   * [,20] - all numbers ≤20 (matches: 20, 21, 22, ...)\n   */\n  const matchInterval = (number, interval) => {\n    interval = parseInterval(interval);\n    if (interval && typeof number === 'number') {\n      if (interval.from.value === number) {\n        return interval.from.included;\n      }\n      if (interval.to.value === number) {\n        return interval.to.included;\n      }\n      return Math.min(interval.from.value, number) === interval.from.value && Math.max(interval.to.value, number) === interval.to.value;\n    }\n    return false;\n  };\n\n  /**\n   * read locale file, translate a msg and write to fs if new\n   */\n  const translate = (locale, singular, plural, skipSyncToAllFiles) => {\n    // add same key to all translations\n    if (!skipSyncToAllFiles && syncFiles) {\n      syncToAllFiles(singular, plural);\n    }\n    if (locale === undefined) {\n      logWarn('WARN: No locale found - check the context of the call to __(). Using ' + defaultLocale + ' as current locale');\n      locale = defaultLocale;\n    }\n\n    // try to get a fallback\n    if (!locales[locale]) {\n      locale = getFallback(locale, fallbacks) || locale;\n    }\n\n    // attempt to read when defined as valid locale\n    if (!locales[locale]) {\n      read(locale);\n    }\n\n    // fallback to default when missed\n    if (!locales[locale]) {\n      logWarn('WARN: Locale ' + locale + \" couldn't be read - check the context of the call to $__. Using \" + defaultLocale + ' (default) as current locale');\n      locale = defaultLocale;\n      read(locale);\n    }\n\n    // dotnotaction add on, @todo: factor out\n    let defaultSingular = singular;\n    let defaultPlural = plural;\n    if (objectNotation) {\n      let indexOfColon = singular.indexOf(':');\n      // We compare against 0 instead of -1 because\n      // we don't really expect the string to start with ':'.\n      if (indexOfColon > 0) {\n        defaultSingular = singular.substring(indexOfColon + 1);\n        singular = singular.substring(0, indexOfColon);\n      }\n      if (plural && typeof plural !== 'number') {\n        indexOfColon = plural.indexOf(':');\n        if (indexOfColon > 0) {\n          defaultPlural = plural.substring(indexOfColon + 1);\n          plural = plural.substring(0, indexOfColon);\n        }\n      }\n    }\n    const accessor = localeAccessor(locale, singular);\n    const mutator = localeMutator(locale, singular);\n\n    // if (plural) {\n    //   if (accessor() == null) {\n    //     mutator({\n    //       'one': defaultSingular || singular,\n    //       'other': defaultPlural || plural\n    //     });\n    //     write(locale);\n    //   }\n    // }\n    // if (accessor() == null) {\n    //   mutator(defaultSingular || singular);\n    //   write(locale);\n    // }\n    if (plural) {\n      if (accessor() == null) {\n        // when retryInDefaultLocale is true - try to set default value from defaultLocale\n        if (retryInDefaultLocale && locale !== defaultLocale) {\n          logDebug('Missing ' + singular + ' in ' + locale + ' retrying in ' + defaultLocale);\n          mutator(translate(defaultLocale, singular, plural, true));\n        } else {\n          mutator({\n            one: defaultSingular || singular,\n            other: defaultPlural || plural\n          });\n        }\n        write(locale);\n      }\n    }\n    if (accessor() == null) {\n      // when retryInDefaultLocale is true - try to set default value from defaultLocale\n      if (retryInDefaultLocale && locale !== defaultLocale) {\n        logDebug('Missing ' + singular + ' in ' + locale + ' retrying in ' + defaultLocale);\n        mutator(translate(defaultLocale, singular, plural, true));\n      } else {\n        mutator(defaultSingular || singular);\n      }\n      write(locale);\n    }\n    return accessor();\n  };\n\n  /**\n   * initialize the same key in all locales\n   * when not already existing, checked via translate\n   */\n  const syncToAllFiles = (singular, plural) => {\n    // iterate over locales and translate again\n    // this will implicitly write/sync missing keys\n    // to the rest of locales\n    for (const l in locales) {\n      translate(l, singular, plural, true);\n    }\n  };\n\n  /**\n   * Allows delayed access to translations nested inside objects.\n   * @param {String} locale The locale to use.\n   * @param {String} singular The singular term to look up.\n   * @param {Boolean} [allowDelayedTraversal=true] Is delayed traversal of the tree allowed?\n   * This parameter is used internally. It allows to signal the accessor that\n   * a translation was not found in the initial lookup and that an invocation\n   * of the accessor may trigger another traversal of the tree.\n   * @returns {Function} A function that, when invoked, returns the current value stored\n   * in the object at the requested location.\n   */\n  const localeAccessor = (locale, singular, allowDelayedTraversal) => {\n    // Bail out on non-existent locales to defend against internal errors.\n    if (!locales[locale]) return Function.prototype;\n\n    // Handle object lookup notation\n    const indexOfDot = objectNotation && singular.lastIndexOf(objectNotation);\n    if (objectNotation && indexOfDot > 0 && indexOfDot < singular.length - 1) {\n      // If delayed traversal wasn't specifically forbidden, it is allowed.\n      if (typeof allowDelayedTraversal === 'undefined') allowDelayedTraversal = true;\n      // The accessor we're trying to find and which we want to return.\n      let accessor = null;\n      // An accessor that returns null.\n      const nullAccessor = () => null;\n      // Do we need to re-traverse the tree upon invocation of the accessor?\n      let reTraverse = false;\n      // Split the provided term and run the callback for each subterm.\n      singular.split(objectNotation).reduce((object, index) => {\n        // Make the accessor return null.\n        accessor = nullAccessor;\n        // If our current target object (in the locale tree) doesn't exist or\n        // it doesn't have the next subterm as a member...\n        if (object === null || !Object.prototype.hasOwnProperty.call(object, index)) {\n          // ...remember that we need retraversal (because we didn't find our target).\n          reTraverse = allowDelayedTraversal;\n          // Return null to avoid deeper iterations.\n          return null;\n        }\n        // We can traverse deeper, so we generate an accessor for this current level.\n        accessor = () => object[index];\n        // Return a reference to the next deeper level in the locale tree.\n        return object[index];\n      }, locales[locale]);\n      // Return the requested accessor.\n      return () =>\n      // If we need to re-traverse (because we didn't find our target term)\n      // traverse again and return the new result (but don't allow further iterations)\n      // or return the previously found accessor if it was already valid.\n      reTraverse ? localeAccessor(locale, singular, false)() : accessor();\n    } else {\n      // No object notation, just return an accessor that performs array lookup.\n      return () => locales[locale][singular];\n    }\n  };\n\n  /**\n   * Allows delayed mutation of a translation nested inside objects.\n   * @description Construction of the mutator will attempt to locate the requested term\n   * inside the object, but if part of the branch does not exist yet, it will not be\n   * created until the mutator is actually invoked. At that point, re-traversal of the\n   * tree is performed and missing parts along the branch will be created.\n   * @param {String} locale The locale to use.\n   * @param {String} singular The singular term to look up.\n   * @param [Boolean} [allowBranching=false] Is the mutator allowed to create previously\n   * non-existent branches along the requested locale path?\n   * @returns {Function} A function that takes one argument. When the function is\n   * invoked, the targeted translation term will be set to the given value inside the locale table.\n   */\n  const localeMutator = function (locale, singular, allowBranching) {\n    // Bail out on non-existent locales to defend against internal errors.\n    if (!locales[locale]) return Function.prototype;\n\n    // Handle object lookup notation\n    const indexOfDot = objectNotation && singular.lastIndexOf(objectNotation);\n    if (objectNotation && indexOfDot > 0 && indexOfDot < singular.length - 1) {\n      // If branching wasn't specifically allowed, disable it.\n      if (typeof allowBranching === 'undefined') allowBranching = false;\n      // This will become the function we want to return.\n      let accessor = null;\n      // An accessor that takes one argument and returns null.\n      const nullAccessor = () => null;\n      // Fix object path.\n      let fixObject = () => ({});\n      // Are we going to need to re-traverse the tree when the mutator is invoked?\n      let reTraverse = false;\n      // Split the provided term and run the callback for each subterm.\n      singular.split(objectNotation).reduce((object, index) => {\n        // Make the mutator do nothing.\n        accessor = nullAccessor;\n        // If our current target object (in the locale tree) doesn't exist or\n        // it doesn't have the next subterm as a member...\n        if (object === null || !Object.prototype.hasOwnProperty.call(object, index)) {\n          // ...check if we're allowed to create new branches.\n          if (allowBranching) {\n            // Fix `object` if `object` is not Object.\n            if (object === null || typeof object !== 'object') {\n              object = fixObject();\n            }\n            // If we are allowed to, create a new object along the path.\n            object[index] = {};\n          } else {\n            // If we aren't allowed, remember that we need to re-traverse later on and...\n            reTraverse = true;\n            // ...return null to make the next iteration bail our early on.\n            return null;\n          }\n        }\n        // Generate a mutator for the current level.\n        accessor = value => {\n          object[index] = value;\n          return value;\n        };\n        // Generate a fixer for the current level.\n        fixObject = () => {\n          object[index] = {};\n          return object[index];\n        };\n\n        // Return a reference to the next deeper level in the locale tree.\n        return object[index];\n      }, locales[locale]);\n\n      // Return the final mutator.\n      return value => {\n        // If we need to re-traverse the tree\n        // invoke the search again, but allow branching\n        // this time (because here the mutator is being invoked)\n        // otherwise, just change the value directly.\n        value = missingKeyFn(locale, value);\n        return reTraverse ? localeMutator(locale, singular, true)(value) : accessor(value);\n      };\n    } else {\n      // No object notation, just return a mutator that performs array lookup and changes the value.\n      return value => {\n        value = missingKeyFn(locale, value);\n        locales[locale][singular] = value;\n        return value;\n      };\n    }\n  };\n\n  /**\n   * try reading a file\n   */\n  const read = locale => {\n    let localeFile = {};\n    const file = getStorageFilePath(locale);\n    try {\n      logDebug('read ' + file + ' for locale: ' + locale);\n      localeFile = fs.readFileSync(file, 'utf-8');\n      try {\n        // parsing filecontents to locales[locale]\n        locales[locale] = parser.parse(localeFile);\n      } catch (parseError) {\n        logError('unable to parse locales from file (maybe ' + file + ' is empty or invalid json?): ', parseError);\n      }\n    } catch (readError) {\n      // unable to read, so intialize that file\n      // locales[locale] are already set in memory, so no extra read required\n      // or locales[locale] are empty, which initializes an empty locale.json file\n      // since the current invalid locale could exist, we should back it up\n      if (fs.existsSync(file)) {\n        logDebug('backing up invalid locale ' + locale + ' to ' + file + '.invalid');\n        fs.renameSync(file, file + '.invalid');\n      }\n      logDebug('initializing ' + file);\n      write(locale);\n    }\n  };\n\n  /**\n   * try writing a file in a created directory\n   */\n  const write = locale => {\n    let stats, target, tmp;\n\n    // don't write new locale information to disk if updateFiles isn't true\n    if (!updateFiles) {\n      return;\n    }\n\n    // creating directory if necessary\n    try {\n      stats = fs.lstatSync(directory);\n    } catch (e) {\n      logDebug('creating locales dir in: ' + directory);\n      try {\n        fs.mkdirSync(directory, directoryPermissions);\n      } catch (e) {\n        // in case of parallel tasks utilizing in same dir\n        if (e.code !== 'EEXIST') throw e;\n      }\n    }\n\n    // first time init has an empty file\n    if (!locales[locale]) {\n      locales[locale] = {};\n    }\n\n    // writing to tmp and rename on success\n    try {\n      target = getStorageFilePath(locale);\n      tmp = target + '.tmp';\n      fs.writeFileSync(tmp, parser.stringify(locales[locale], null, indent), 'utf8');\n      stats = fs.statSync(tmp);\n      if (stats.isFile()) {\n        fs.renameSync(tmp, target);\n      } else {\n        logError('unable to write locales to file (either ' + tmp + ' or ' + target + ' are not writeable?): ');\n      }\n    } catch (e) {\n      logError('unexpected error writing files (either ' + tmp + ' or ' + target + ' are not writeable?): ', e);\n    }\n  };\n\n  /**\n   * basic normalization of filepath\n   */\n  const getStorageFilePath = locale => {\n    // changed API to use .json as default, #16\n    const ext = extension || '.json';\n    const filepath = path.normalize(directory + pathsep + prefix + locale + ext);\n    const filepathJS = path.normalize(directory + pathsep + prefix + locale + '.js');\n    // use .js as fallback if already existing\n    try {\n      if (fs.statSync(filepathJS)) {\n        logDebug('using existing file ' + filepathJS);\n        extension = '.js';\n        return filepathJS;\n      }\n    } catch (e) {\n      logDebug('will use ' + filepath);\n    }\n    return filepath;\n  };\n\n  /**\n   * Get locales with wildcard support\n   */\n  const getFallback = (targetLocale, fallbacks) => {\n    fallbacks = fallbacks || {};\n    if (fallbacks[targetLocale]) return fallbacks[targetLocale];\n    let fallBackLocale = null;\n    for (const key in fallbacks) {\n      if (targetLocale.match(new RegExp('^' + key.replace('*', '.*') + '$'))) {\n        fallBackLocale = fallbacks[key];\n        break;\n      }\n    }\n    return fallBackLocale;\n  };\n\n  /**\n   * Logging proxies\n   */\n  const logDebug = msg => {\n    logDebugFn(msg);\n  };\n  const logWarn = msg => {\n    logWarnFn(msg);\n  };\n  const logError = msg => {\n    logErrorFn(msg);\n  };\n\n  /**\n   * Missing key function\n   */\n  const missingKey = (locale, value) => {\n    return value;\n  };\n\n  /**\n   * implicitly configure when created with given options\n   * @example\n   * const i18n = new I18n({\n   *   locales: ['en', 'fr']\n   * });\n   */\n  if (_OPTS) i18n.configure(_OPTS);\n  return i18n;\n};\nmodule.exports = i18n;","map":{"version":3,"names":["printf","require","pkgVersion","version","fs","url","path","debug","warn","error","Mustache","Messageformat","MakePlural","parseInterval","default","escapeRegExp","string","replace","i18n","I18n","_OPTS","MessageformatInstanceForLocale","PluralsForLocale","locales","api","__","__n","__l","__h","__mf","getLocale","setLocale","getCatalog","getLocales","addLocale","removeLocale","mustacheConfig","tags","disable","mustacheRegex","pathsep","sep","autoReload","cookiename","languageHeaderName","defaultLocale","retryInDefaultLocale","directory","directoryPermissions","extension","fallbacks","indent","logDebugFn","logErrorFn","logWarnFn","preserveLegacyCase","objectNotation","prefix","queryParameter","register","updateFiles","syncFiles","missingKeyFn","parser","configure","i18nConfigure","opt","method","Object","prototype","hasOwnProperty","call","alias","Array","isArray","forEach","applyAPItoObject","cookie","header","join","__dirname","parseInt","missingKey","parse","stringify","JSON","staticCatalog","keys","guessLocales","start","end","RegExp","read","watch","event","filename","localeFromFile","guessLocaleFromFile","indexOf","logDebug","init","i18nInit","request","response","next","guessLanguage","locale","logError","i18nTranslate","phrase","msg","argv","parseArgv","arguments","namedValues","args","translate","getLocaleFromObject","one","other","postProcess","i18nMessageformat","mf","f","targetLocale","compiledFunctions","compile","i18nTranslationList","translations","sort","l","push","i18nTranslationHash","hash","i18nTranslatePlural","singular","plural","count","argsEndWithNamedObject","length","slice","unshift","Number","p","lc","toLowerCase","split","filter","el","i18nSetLocale","object","skipImplicitObjects","i","targetObject","undefined","getFallback","r","res","locals","i18nGetLocale","i18nGetCatalog","global","logWarn","i18nGetLocales","i18nAddLocale","i18nRemoveLocale","test","parsePluralInterval","render","returnArgs","alreadySetted","bind","entries","readdirSync","localesFound","match","extensionRegex","prefixRegex","extractQueryLanguage","queryLanguage","find","lang","languageHeader","headers","languages","regions","language","region","urlAsString","toString","urlObj","languageQueryParameter","query","cookies","acceptedLanguages","getAcceptedLanguagesFromHeader","fallbackMatch","fallback","lr","parentLang","fallbackLang","acceptedLanguageIndex","fallbackIndex","splice","fallbackParentLang","preferences","map","item","preferenceParts","trim","quality","parseFloat","a","b","obj","scope","returnPhrase","phrases","intervalRuleExists","some","matches","matchInterval","number","interval","from","value","included","to","Math","min","max","skipSyncToAllFiles","syncToAllFiles","defaultSingular","defaultPlural","indexOfColon","substring","accessor","localeAccessor","mutator","localeMutator","write","allowDelayedTraversal","Function","indexOfDot","lastIndexOf","nullAccessor","reTraverse","reduce","index","allowBranching","fixObject","localeFile","file","getStorageFilePath","readFileSync","parseError","readError","existsSync","renameSync","stats","target","tmp","lstatSync","e","mkdirSync","code","writeFileSync","statSync","isFile","ext","filepath","normalize","filepathJS","fallBackLocale","key","module","exports"],"sources":["C:/Users/grhys/Acr0batOG.github.io/app/client/node_modules/i18n/i18n.js"],"sourcesContent":["/**\n * @author      Created by Marcus Spiegel <spiegel@uscreen.de> on 2011-03-25.\n * @link        https://github.com/mashpie/i18n-node\n * @license     http://opensource.org/licenses/MIT\n */\n\n'use strict'\n\n// dependencies\nconst printf = require('fast-printf').printf\nconst pkgVersion = require('./package.json').version\nconst fs = require('fs')\nconst url = require('url')\nconst path = require('path')\nconst debug = require('debug')('i18n:debug')\nconst warn = require('debug')('i18n:warn')\nconst error = require('debug')('i18n:error')\nconst Mustache = require('mustache')\nconst Messageformat = require('@messageformat/core')\nconst MakePlural = require('make-plural')\nconst parseInterval = require('math-interval-parser').default\n\n// utils\nconst escapeRegExp = (string) => string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&') // $& means the whole matched string\n\n/**\n * create constructor function\n */\nconst i18n = function I18n(_OPTS = false) {\n  const MessageformatInstanceForLocale = {}\n  const PluralsForLocale = {}\n  let locales = {}\n  const api = {\n    __: '__',\n    __n: '__n',\n    __l: '__l',\n    __h: '__h',\n    __mf: '__mf',\n    getLocale: 'getLocale',\n    setLocale: 'setLocale',\n    getCatalog: 'getCatalog',\n    getLocales: 'getLocales',\n    addLocale: 'addLocale',\n    removeLocale: 'removeLocale'\n  }\n  const mustacheConfig = {\n    tags: ['{{', '}}'],\n    disable: false\n  }\n\n  let mustacheRegex\n  const pathsep = path.sep // ---> means win support will be available in node 0.8.x and above\n  let autoReload\n  let cookiename\n  let languageHeaderName\n  let defaultLocale\n  let retryInDefaultLocale\n  let directory\n  let directoryPermissions\n  let extension\n  let fallbacks\n  let indent\n  let logDebugFn\n  let logErrorFn\n  let logWarnFn\n  let preserveLegacyCase\n  let objectNotation\n  let prefix\n  let queryParameter\n  let register\n  let updateFiles\n  let syncFiles\n  let missingKeyFn\n  let parser\n\n  // public exports\n  const i18n = {}\n\n  i18n.version = pkgVersion\n\n  i18n.configure = function i18nConfigure(opt) {\n    // reset locales\n    locales = {}\n\n    // Provide custom API method aliases if desired\n    // This needs to be processed before the first call to applyAPItoObject()\n    if (opt.api && typeof opt.api === 'object') {\n      for (const method in opt.api) {\n        if (Object.prototype.hasOwnProperty.call(opt.api, method)) {\n          const alias = opt.api[method]\n          if (typeof api[method] !== 'undefined') {\n            api[method] = alias\n          }\n        }\n      }\n    }\n\n    // you may register i18n in global scope, up to you\n    if (typeof opt.register === 'object') {\n      register = opt.register\n      // or give an array objects to register to\n      if (Array.isArray(opt.register)) {\n        register = opt.register\n        register.forEach(applyAPItoObject)\n      } else {\n        applyAPItoObject(opt.register)\n      }\n    }\n\n    // sets a custom cookie name to parse locale settings from\n    cookiename = typeof opt.cookie === 'string' ? opt.cookie : null\n\n    // set the custom header name to extract the language locale\n    languageHeaderName =\n      typeof opt.header === 'string' ? opt.header : 'accept-language'\n\n    // query-string parameter to be watched - @todo: add test & doc\n    queryParameter =\n      typeof opt.queryParameter === 'string' ? opt.queryParameter : null\n\n    // where to store json files\n    directory =\n      typeof opt.directory === 'string'\n        ? opt.directory\n        : path.join(__dirname, 'locales')\n\n    // permissions when creating new directories\n    directoryPermissions =\n      typeof opt.directoryPermissions === 'string'\n        ? parseInt(opt.directoryPermissions, 8)\n        : null\n\n    // write new locale information to disk\n    updateFiles = typeof opt.updateFiles === 'boolean' ? opt.updateFiles : true\n\n    // sync locale information accros all files\n    syncFiles = typeof opt.syncFiles === 'boolean' ? opt.syncFiles : false\n\n    // what to use as the indentation unit (ex: \"\\t\", \"  \")\n    indent = typeof opt.indent === 'string' ? opt.indent : '\\t'\n\n    // json files prefix\n    prefix = typeof opt.prefix === 'string' ? opt.prefix : ''\n\n    // where to store json files\n    extension = typeof opt.extension === 'string' ? opt.extension : '.json'\n\n    // setting defaultLocale\n    defaultLocale =\n      typeof opt.defaultLocale === 'string' ? opt.defaultLocale : 'en'\n\n    // allow to retry in default locale, useful for production\n    retryInDefaultLocale =\n      typeof opt.retryInDefaultLocale === 'boolean'\n        ? opt.retryInDefaultLocale\n        : false\n\n    // auto reload locale files when changed\n    autoReload = typeof opt.autoReload === 'boolean' ? opt.autoReload : false\n\n    // enable object notation?\n    objectNotation =\n      typeof opt.objectNotation !== 'undefined' ? opt.objectNotation : false\n    if (objectNotation === true) objectNotation = '.'\n\n    // read language fallback map\n    fallbacks = typeof opt.fallbacks === 'object' ? opt.fallbacks : {}\n\n    // setting custom logger functions\n    logDebugFn = typeof opt.logDebugFn === 'function' ? opt.logDebugFn : debug\n    logWarnFn = typeof opt.logWarnFn === 'function' ? opt.logWarnFn : warn\n    logErrorFn = typeof opt.logErrorFn === 'function' ? opt.logErrorFn : error\n\n    preserveLegacyCase =\n      typeof opt.preserveLegacyCase === 'boolean'\n        ? opt.preserveLegacyCase\n        : true\n\n    // setting custom missing key function\n    missingKeyFn =\n      typeof opt.missingKeyFn === 'function' ? opt.missingKeyFn : missingKey\n\n    parser =\n      typeof opt.parser === 'object' &&\n      typeof opt.parser.parse === 'function' &&\n      typeof opt.parser.stringify === 'function'\n        ? opt.parser\n        : JSON\n\n    // when missing locales we try to guess that from directory\n    opt.locales = opt.staticCatalog\n      ? Object.keys(opt.staticCatalog)\n      : opt.locales || guessLocales(directory)\n\n    // some options should be disabled when using staticCatalog\n    if (opt.staticCatalog) {\n      updateFiles = false\n      autoReload = false\n      syncFiles = false\n    }\n\n    // customize mustache parsing\n    if (opt.mustacheConfig) {\n      if (Array.isArray(opt.mustacheConfig.tags)) {\n        mustacheConfig.tags = opt.mustacheConfig.tags\n      }\n      if (opt.mustacheConfig.disable === true) {\n        mustacheConfig.disable = true\n      }\n    }\n\n    const [start, end] = mustacheConfig.tags\n    mustacheRegex = new RegExp(escapeRegExp(start) + '.*' + escapeRegExp(end))\n\n    // implicitly read all locales\n    if (Array.isArray(opt.locales)) {\n      if (opt.staticCatalog) {\n        locales = opt.staticCatalog\n      } else {\n        opt.locales.forEach(read)\n      }\n\n      // auto reload locale files when changed\n      if (autoReload) {\n        // watch changes of locale files (it's called twice because fs.watch is still unstable)\n        fs.watch(directory, (event, filename) => {\n          const localeFromFile = guessLocaleFromFile(filename)\n\n          if (localeFromFile && opt.locales.indexOf(localeFromFile) > -1) {\n            logDebug('Auto reloading locale file \"' + filename + '\".')\n            read(localeFromFile)\n          }\n        })\n      }\n    }\n  }\n\n  i18n.init = function i18nInit(request, response, next) {\n    if (typeof request === 'object') {\n      // guess requested language/locale\n      guessLanguage(request)\n\n      // bind api to req\n      applyAPItoObject(request)\n\n      // looks double but will ensure schema on api refactor\n      i18n.setLocale(request, request.locale)\n    } else {\n      return logError(\n        'i18n.init must be called with one parameter minimum, ie. i18n.init(req)'\n      )\n    }\n\n    if (typeof response === 'object') {\n      applyAPItoObject(response)\n\n      // and set that locale to response too\n      i18n.setLocale(response, request.locale)\n    }\n\n    // head over to next callback when bound as middleware\n    if (typeof next === 'function') {\n      return next()\n    }\n  }\n\n  i18n.__ = function i18nTranslate(phrase) {\n    let msg\n    const argv = parseArgv(arguments)\n    const namedValues = argv[0]\n    const args = argv[1]\n\n    // called like __({phrase: \"Hello\", locale: \"en\"})\n    if (typeof phrase === 'object') {\n      if (\n        typeof phrase.locale === 'string' &&\n        typeof phrase.phrase === 'string'\n      ) {\n        msg = translate(phrase.locale, phrase.phrase)\n      }\n    }\n    // called like __(\"Hello\")\n    else {\n      // get translated message with locale from scope (deprecated) or object\n      msg = translate(getLocaleFromObject(this), phrase)\n    }\n\n    // postprocess to get compatible to plurals\n    if (typeof msg === 'object' && msg.one) {\n      msg = msg.one\n    }\n\n    // in case there is no 'one' but an 'other' rule\n    if (typeof msg === 'object' && msg.other) {\n      msg = msg.other\n    }\n\n    // head over to postProcessing\n    return postProcess(msg, namedValues, args)\n  }\n\n  i18n.__mf = function i18nMessageformat(phrase) {\n    let msg, mf, f\n    let targetLocale = defaultLocale\n    const argv = parseArgv(arguments)\n    const namedValues = argv[0]\n    const args = argv[1]\n\n    // called like __({phrase: \"Hello\", locale: \"en\"})\n    if (typeof phrase === 'object') {\n      if (\n        typeof phrase.locale === 'string' &&\n        typeof phrase.phrase === 'string'\n      ) {\n        msg = phrase.phrase\n        targetLocale = phrase.locale\n      }\n    }\n    // called like __(\"Hello\")\n    else {\n      // get translated message with locale from scope (deprecated) or object\n      msg = phrase\n      targetLocale = getLocaleFromObject(this)\n    }\n\n    msg = translate(targetLocale, msg)\n    // --- end get msg\n\n    // now head over to Messageformat\n    // and try to cache instance\n    if (MessageformatInstanceForLocale[targetLocale]) {\n      mf = MessageformatInstanceForLocale[targetLocale]\n    } else {\n      mf = new Messageformat(targetLocale)\n\n      mf.compiledFunctions = {}\n      MessageformatInstanceForLocale[targetLocale] = mf\n    }\n\n    // let's try to cache that function\n    if (mf.compiledFunctions[msg]) {\n      f = mf.compiledFunctions[msg]\n    } else {\n      f = mf.compile(msg)\n      mf.compiledFunctions[msg] = f\n    }\n\n    return postProcess(f(namedValues), namedValues, args)\n  }\n\n  i18n.__l = function i18nTranslationList(phrase) {\n    const translations = []\n    Object.keys(locales)\n      .sort()\n      .forEach((l) => {\n        translations.push(i18n.__({ phrase: phrase, locale: l }))\n      })\n    return translations\n  }\n\n  i18n.__h = function i18nTranslationHash(phrase) {\n    const translations = []\n    Object.keys(locales)\n      .sort()\n      .forEach((l) => {\n        const hash = {}\n        hash[l] = i18n.__({ phrase: phrase, locale: l })\n        translations.push(hash)\n      })\n    return translations\n  }\n\n  i18n.__n = function i18nTranslatePlural(singular, plural, count) {\n    let msg\n    let namedValues\n    let targetLocale\n    let args = []\n\n    // Accept an object with named values as the last parameter\n    if (argsEndWithNamedObject(arguments)) {\n      namedValues = arguments[arguments.length - 1]\n      args =\n        arguments.length >= 5\n          ? Array.prototype.slice.call(arguments, 3, -1)\n          : []\n    } else {\n      namedValues = {}\n      args =\n        arguments.length >= 4 ? Array.prototype.slice.call(arguments, 3) : []\n    }\n\n    // called like __n({singular: \"%s cat\", plural: \"%s cats\", locale: \"en\"}, 3)\n    if (typeof singular === 'object') {\n      if (\n        typeof singular.locale === 'string' &&\n        typeof singular.singular === 'string' &&\n        typeof singular.plural === 'string'\n      ) {\n        targetLocale = singular.locale\n        msg = translate(singular.locale, singular.singular, singular.plural)\n      }\n      args.unshift(count)\n\n      // some template engines pass all values as strings -> so we try to convert them to numbers\n      if (typeof plural === 'number' || Number(plural) + '' === plural) {\n        count = plural\n      }\n\n      // called like __n({singular: \"%s cat\", plural: \"%s cats\", locale: \"en\", count: 3})\n      if (\n        typeof singular.count === 'number' ||\n        typeof singular.count === 'string'\n      ) {\n        count = singular.count\n        args.unshift(plural)\n      }\n    } else {\n      // called like  __n('cat', 3)\n      if (typeof plural === 'number' || Number(plural) + '' === plural) {\n        count = plural\n\n        // we add same string as default\n        // which efectivly copies the key to the plural.value\n        // this is for initialization of new empty translations\n        plural = singular\n\n        args.unshift(count)\n        args.unshift(plural)\n      }\n      // called like __n('%s cat', '%s cats', 3)\n      // get translated message with locale from scope (deprecated) or object\n      msg = translate(getLocaleFromObject(this), singular, plural)\n      targetLocale = getLocaleFromObject(this)\n    }\n\n    if (count === null) count = namedValues.count\n\n    // enforce number\n    count = Number(count)\n\n    // find the correct plural rule for given locale\n    if (typeof msg === 'object') {\n      let p\n      // create a new Plural for locale\n      // and try to cache instance\n      if (PluralsForLocale[targetLocale]) {\n        p = PluralsForLocale[targetLocale]\n      } else {\n        // split locales with a region code\n        const lc = targetLocale\n          .toLowerCase()\n          .split(/[_-\\s]+/)\n          .filter((el) => true && el)\n        // take the first part of locale, fallback to full locale\n        p = MakePlural[lc[0] || targetLocale]\n        PluralsForLocale[targetLocale] = p\n      }\n\n      // fallback to 'other' on case of missing translations\n      msg = msg[p(count)] || msg.other\n    }\n\n    // head over to postProcessing\n    return postProcess(msg, namedValues, args, count)\n  }\n\n  i18n.setLocale = function i18nSetLocale(object, locale, skipImplicitObjects) {\n    // when given an array of objects => setLocale on each\n    if (Array.isArray(object) && typeof locale === 'string') {\n      for (let i = object.length - 1; i >= 0; i--) {\n        i18n.setLocale(object[i], locale, true)\n      }\n      return i18n.getLocale(object[0])\n    }\n\n    // defaults to called like i18n.setLocale(req, 'en')\n    let targetObject = object\n    let targetLocale = locale\n\n    // called like req.setLocale('en') or i18n.setLocale('en')\n    if (locale === undefined && typeof object === 'string') {\n      targetObject = this\n      targetLocale = object\n    }\n\n    // consider a fallback\n    if (!locales[targetLocale]) {\n      targetLocale = getFallback(targetLocale, fallbacks) || targetLocale\n    }\n\n    // now set locale on object\n    targetObject.locale = locales[targetLocale] ? targetLocale : defaultLocale\n\n    // consider any extra registered objects\n    if (typeof register === 'object') {\n      if (Array.isArray(register) && !skipImplicitObjects) {\n        register.forEach((r) => {\n          r.locale = targetObject.locale\n        })\n      } else {\n        register.locale = targetObject.locale\n      }\n    }\n\n    // consider res\n    if (targetObject.res && !skipImplicitObjects) {\n      // escape recursion\n      // @see  - https://github.com/balderdashy/sails/pull/3631\n      //       - https://github.com/mashpie/i18n-node/pull/218\n      if (targetObject.res.locals) {\n        i18n.setLocale(targetObject.res, targetObject.locale, true)\n        i18n.setLocale(targetObject.res.locals, targetObject.locale, true)\n      } else {\n        i18n.setLocale(targetObject.res, targetObject.locale)\n      }\n    }\n\n    // consider locals\n    if (targetObject.locals && !skipImplicitObjects) {\n      // escape recursion\n      // @see  - https://github.com/balderdashy/sails/pull/3631\n      //       - https://github.com/mashpie/i18n-node/pull/218\n      if (targetObject.locals.res) {\n        i18n.setLocale(targetObject.locals, targetObject.locale, true)\n        i18n.setLocale(targetObject.locals.res, targetObject.locale, true)\n      } else {\n        i18n.setLocale(targetObject.locals, targetObject.locale)\n      }\n    }\n\n    return i18n.getLocale(targetObject)\n  }\n\n  i18n.getLocale = function i18nGetLocale(request) {\n    // called like i18n.getLocale(req)\n    if (request && request.locale) {\n      return request.locale\n    }\n\n    // called like req.getLocale()\n    return this.locale || defaultLocale\n  }\n\n  i18n.getCatalog = function i18nGetCatalog(object, locale) {\n    let targetLocale\n\n    // called like i18n.getCatalog(req)\n    if (\n      typeof object === 'object' &&\n      typeof object.locale === 'string' &&\n      locale === undefined\n    ) {\n      targetLocale = object.locale\n    }\n\n    // called like i18n.getCatalog(req, 'en')\n    if (\n      !targetLocale &&\n      typeof object === 'object' &&\n      typeof locale === 'string'\n    ) {\n      targetLocale = locale\n    }\n\n    // called like req.getCatalog('en')\n    if (!targetLocale && locale === undefined && typeof object === 'string') {\n      targetLocale = object\n    }\n\n    // called like req.getCatalog()\n    if (\n      !targetLocale &&\n      object === undefined &&\n      locale === undefined &&\n      typeof this.locale === 'string'\n    ) {\n      if (register && register.global) {\n        targetLocale = ''\n      } else {\n        targetLocale = this.locale\n      }\n    }\n\n    // called like i18n.getCatalog()\n    if (targetLocale === undefined || targetLocale === '') {\n      return locales\n    }\n\n    if (!locales[targetLocale]) {\n      targetLocale = getFallback(targetLocale, fallbacks) || targetLocale\n    }\n\n    if (locales[targetLocale]) {\n      return locales[targetLocale]\n    } else {\n      logWarn('No catalog found for \"' + targetLocale + '\"')\n      return false\n    }\n  }\n\n  i18n.getLocales = function i18nGetLocales() {\n    return Object.keys(locales)\n  }\n\n  i18n.addLocale = function i18nAddLocale(locale) {\n    read(locale)\n  }\n\n  i18n.removeLocale = function i18nRemoveLocale(locale) {\n    delete locales[locale]\n  }\n\n  // ===================\n  // = private methods =\n  // ===================\n\n  const postProcess = (msg, namedValues, args, count) => {\n    // test for parsable interval string\n    if (/\\|/.test(msg)) {\n      msg = parsePluralInterval(msg, count)\n    }\n\n    // replace the counter\n    if (typeof count === 'number') {\n      msg = printf(msg, Number(count))\n    }\n\n    // if the msg string contains {{Mustache}} patterns we render it as a mini template\n    if (!mustacheConfig.disable && mustacheRegex.test(msg)) {\n      msg = Mustache.render(msg, namedValues, {}, mustacheConfig.tags)\n    }\n\n    // if we have extra arguments with values to get replaced,\n    // an additional substition injects those strings afterwards\n    if (/%/.test(msg) && args && args.length > 0) {\n      msg = printf(msg, ...args)\n    }\n\n    return msg\n  }\n\n  const argsEndWithNamedObject = (args) =>\n    args.length > 1 &&\n    args[args.length - 1] !== null &&\n    typeof args[args.length - 1] === 'object'\n\n  const parseArgv = (args) => {\n    let namedValues, returnArgs\n\n    if (argsEndWithNamedObject(args)) {\n      namedValues = args[args.length - 1]\n      returnArgs = Array.prototype.slice.call(args, 1, -1)\n    } else {\n      namedValues = {}\n      returnArgs = args.length >= 2 ? Array.prototype.slice.call(args, 1) : []\n    }\n\n    return [namedValues, returnArgs]\n  }\n\n  /**\n   * registers all public API methods to a given response object when not already declared\n   */\n  const applyAPItoObject = (object) => {\n    let alreadySetted = true\n\n    // attach to itself if not provided\n    for (const method in api) {\n      if (Object.prototype.hasOwnProperty.call(api, method)) {\n        const alias = api[method]\n\n        // be kind rewind, or better not touch anything already existing\n        if (!object[alias]) {\n          alreadySetted = false\n          object[alias] = i18n[method].bind(object)\n        }\n      }\n    }\n\n    // set initial locale if not set\n    if (!object.locale) {\n      object.locale = defaultLocale\n    }\n\n    // escape recursion\n    if (alreadySetted) {\n      return\n    }\n\n    // attach to response if present (ie. in express)\n    if (object.res) {\n      applyAPItoObject(object.res)\n    }\n\n    // attach to locals if present (ie. in express)\n    if (object.locals) {\n      applyAPItoObject(object.locals)\n    }\n  }\n\n  /**\n   * tries to guess locales by scanning the given directory\n   */\n  const guessLocales = (directory) => {\n    const entries = fs.readdirSync(directory)\n    const localesFound = []\n\n    for (let i = entries.length - 1; i >= 0; i--) {\n      if (entries[i].match(/^\\./)) continue\n      const localeFromFile = guessLocaleFromFile(entries[i])\n      if (localeFromFile) localesFound.push(localeFromFile)\n    }\n\n    return localesFound.sort()\n  }\n\n  /**\n   * tries to guess locales from a given filename\n   */\n  const guessLocaleFromFile = (filename) => {\n    const extensionRegex = new RegExp(extension + '$', 'g')\n    const prefixRegex = new RegExp('^' + prefix, 'g')\n\n    if (!filename) return false\n    if (prefix && !filename.match(prefixRegex)) return false\n    if (extension && !filename.match(extensionRegex)) return false\n    return filename.replace(prefix, '').replace(extensionRegex, '')\n  }\n\n  /**\n   * @param queryLanguage - language query parameter, either an array or a string.\n   * @return the first non-empty language query parameter found, null otherwise.\n   */\n  const extractQueryLanguage = (queryLanguage) => {\n    if (Array.isArray(queryLanguage)) {\n      return queryLanguage.find((lang) => lang !== '' && lang)\n    }\n    return typeof queryLanguage === 'string' && queryLanguage\n  }\n\n  /**\n   * guess language setting based on http headers\n   */\n\n  const guessLanguage = (request) => {\n    if (typeof request === 'object') {\n      const languageHeader = request.headers\n        ? request.headers[languageHeaderName]\n        : undefined\n      const languages = []\n      const regions = []\n\n      request.languages = [defaultLocale]\n      request.regions = [defaultLocale]\n      request.language = defaultLocale\n      request.region = defaultLocale\n\n      // a query parameter overwrites all\n      if (queryParameter && request.url) {\n        const urlAsString =\n          typeof request.url === 'string' ? request.url : request.url.toString()\n\n        /**\n         * @todo WHATWG new URL() requires full URL including hostname - that might change\n         * @see https://github.com/nodejs/node/issues/12682\n         */\n        // eslint-disable-next-line node/no-deprecated-api\n        const urlObj = url.parse(urlAsString, true)\n        const languageQueryParameter = urlObj.query[queryParameter]\n        if (languageQueryParameter) {\n          let queryLanguage = extractQueryLanguage(languageQueryParameter)\n          if (queryLanguage) {\n            logDebug('Overriding locale from query: ' + queryLanguage)\n            if (preserveLegacyCase) {\n              queryLanguage = queryLanguage.toLowerCase()\n            }\n            return i18n.setLocale(request, queryLanguage)\n          }\n        }\n      }\n\n      // a cookie overwrites headers\n      if (cookiename && request.cookies && request.cookies[cookiename]) {\n        request.language = request.cookies[cookiename]\n        return i18n.setLocale(request, request.language)\n      }\n\n      // 'accept-language' is the most common source\n      if (languageHeader) {\n        const acceptedLanguages = getAcceptedLanguagesFromHeader(languageHeader)\n        let match\n        let fallbackMatch\n        let fallback\n        for (let i = 0; i < acceptedLanguages.length; i++) {\n          const lang = acceptedLanguages[i]\n          const lr = lang.split('-', 2)\n          const parentLang = lr[0]\n          const region = lr[1]\n\n          // Check if we have a configured fallback set for this language.\n          const fallbackLang = getFallback(lang, fallbacks)\n          if (fallbackLang) {\n            fallback = fallbackLang\n            // Fallbacks for languages should be inserted\n            // where the original, unsupported language existed.\n            const acceptedLanguageIndex = acceptedLanguages.indexOf(lang)\n            const fallbackIndex = acceptedLanguages.indexOf(fallback)\n            if (fallbackIndex > -1) {\n              acceptedLanguages.splice(fallbackIndex, 1)\n            }\n            acceptedLanguages.splice(acceptedLanguageIndex + 1, 0, fallback)\n          }\n\n          // Check if we have a configured fallback set for the parent language of the locale.\n          const fallbackParentLang = getFallback(parentLang, fallbacks)\n          if (fallbackParentLang) {\n            fallback = fallbackParentLang\n            // Fallbacks for a parent language should be inserted\n            // to the end of the list, so they're only picked\n            // if there is no better match.\n            if (acceptedLanguages.indexOf(fallback) < 0) {\n              acceptedLanguages.push(fallback)\n            }\n          }\n\n          if (languages.indexOf(parentLang) < 0) {\n            languages.push(parentLang.toLowerCase())\n          }\n          if (region) {\n            regions.push(region.toLowerCase())\n          }\n\n          if (!match && locales[lang]) {\n            match = lang\n            break\n          }\n\n          if (!fallbackMatch && locales[parentLang]) {\n            fallbackMatch = parentLang\n          }\n        }\n\n        request.language = match || fallbackMatch || request.language\n        request.region = regions[0] || request.region\n        return i18n.setLocale(request, request.language)\n      }\n    }\n\n    // last resort: defaultLocale\n    return i18n.setLocale(request, defaultLocale)\n  }\n\n  /**\n   * Get a sorted list of accepted languages from the HTTP Accept-Language header\n   */\n  const getAcceptedLanguagesFromHeader = (header) => {\n    const languages = header.split(',')\n    const preferences = {}\n    return languages\n      .map((item) => {\n        const preferenceParts = item.trim().split(';q=')\n        if (preferenceParts.length < 2) {\n          preferenceParts[1] = 1.0\n        } else {\n          const quality = parseFloat(preferenceParts[1])\n          preferenceParts[1] = quality || 0.0\n        }\n        preferences[preferenceParts[0]] = preferenceParts[1]\n\n        return preferenceParts[0]\n      })\n      .filter((lang) => preferences[lang] > 0)\n      .sort((a, b) => preferences[b] - preferences[a])\n  }\n\n  /**\n   * searches for locale in given object\n   */\n\n  const getLocaleFromObject = (obj) => {\n    let locale\n    if (obj && obj.scope) {\n      locale = obj.scope.locale\n    }\n    if (obj && obj.locale) {\n      locale = obj.locale\n    }\n    return locale\n  }\n\n  /**\n   * splits and parses a phrase for mathematical interval expressions\n   */\n  const parsePluralInterval = (phrase, count) => {\n    let returnPhrase = phrase\n    const phrases = phrase.split(/\\|/)\n    let intervalRuleExists = false\n\n    // some() breaks on 1st true\n    phrases.some((p) => {\n      const matches = p.match(/^\\s*([()[\\]]+[\\d,]+[()[\\]]+)?\\s*(.*)$/)\n\n      // not the same as in combined condition\n      if (matches != null && matches[1]) {\n        intervalRuleExists = true\n        if (matchInterval(count, matches[1]) === true) {\n          returnPhrase = matches[2]\n          return true\n        }\n      } else {\n        // this is a other or catch all case, this only is taken into account if there is actually another rule\n        if (intervalRuleExists) {\n          returnPhrase = p\n        }\n      }\n      return false\n    })\n    return returnPhrase\n  }\n\n  /**\n   * test a number to match mathematical interval expressions\n   * [0,2] - 0 to 2 (including, matches: 0, 1, 2)\n   * ]0,3[ - 0 to 3 (excluding, matches: 1, 2)\n   * [1]   - 1 (matches: 1)\n   * [20,] - all numbers ≥20 (matches: 20, 21, 22, ...)\n   * [,20] - all numbers ≤20 (matches: 20, 21, 22, ...)\n   */\n  const matchInterval = (number, interval) => {\n    interval = parseInterval(interval)\n    if (interval && typeof number === 'number') {\n      if (interval.from.value === number) {\n        return interval.from.included\n      }\n      if (interval.to.value === number) {\n        return interval.to.included\n      }\n\n      return (\n        Math.min(interval.from.value, number) === interval.from.value &&\n        Math.max(interval.to.value, number) === interval.to.value\n      )\n    }\n    return false\n  }\n\n  /**\n   * read locale file, translate a msg and write to fs if new\n   */\n  const translate = (locale, singular, plural, skipSyncToAllFiles) => {\n    // add same key to all translations\n    if (!skipSyncToAllFiles && syncFiles) {\n      syncToAllFiles(singular, plural)\n    }\n\n    if (locale === undefined) {\n      logWarn(\n        'WARN: No locale found - check the context of the call to __(). Using ' +\n          defaultLocale +\n          ' as current locale'\n      )\n      locale = defaultLocale\n    }\n\n    // try to get a fallback\n    if (!locales[locale]) {\n      locale = getFallback(locale, fallbacks) || locale\n    }\n\n    // attempt to read when defined as valid locale\n    if (!locales[locale]) {\n      read(locale)\n    }\n\n    // fallback to default when missed\n    if (!locales[locale]) {\n      logWarn(\n        'WARN: Locale ' +\n          locale +\n          \" couldn't be read - check the context of the call to $__. Using \" +\n          defaultLocale +\n          ' (default) as current locale'\n      )\n\n      locale = defaultLocale\n      read(locale)\n    }\n\n    // dotnotaction add on, @todo: factor out\n    let defaultSingular = singular\n    let defaultPlural = plural\n    if (objectNotation) {\n      let indexOfColon = singular.indexOf(':')\n      // We compare against 0 instead of -1 because\n      // we don't really expect the string to start with ':'.\n      if (indexOfColon > 0) {\n        defaultSingular = singular.substring(indexOfColon + 1)\n        singular = singular.substring(0, indexOfColon)\n      }\n      if (plural && typeof plural !== 'number') {\n        indexOfColon = plural.indexOf(':')\n        if (indexOfColon > 0) {\n          defaultPlural = plural.substring(indexOfColon + 1)\n          plural = plural.substring(0, indexOfColon)\n        }\n      }\n    }\n\n    const accessor = localeAccessor(locale, singular)\n    const mutator = localeMutator(locale, singular)\n\n    // if (plural) {\n    //   if (accessor() == null) {\n    //     mutator({\n    //       'one': defaultSingular || singular,\n    //       'other': defaultPlural || plural\n    //     });\n    //     write(locale);\n    //   }\n    // }\n    // if (accessor() == null) {\n    //   mutator(defaultSingular || singular);\n    //   write(locale);\n    // }\n    if (plural) {\n      if (accessor() == null) {\n        // when retryInDefaultLocale is true - try to set default value from defaultLocale\n        if (retryInDefaultLocale && locale !== defaultLocale) {\n          logDebug(\n            'Missing ' +\n              singular +\n              ' in ' +\n              locale +\n              ' retrying in ' +\n              defaultLocale\n          )\n          mutator(translate(defaultLocale, singular, plural, true))\n        } else {\n          mutator({\n            one: defaultSingular || singular,\n            other: defaultPlural || plural\n          })\n        }\n        write(locale)\n      }\n    }\n\n    if (accessor() == null) {\n      // when retryInDefaultLocale is true - try to set default value from defaultLocale\n      if (retryInDefaultLocale && locale !== defaultLocale) {\n        logDebug(\n          'Missing ' +\n            singular +\n            ' in ' +\n            locale +\n            ' retrying in ' +\n            defaultLocale\n        )\n        mutator(translate(defaultLocale, singular, plural, true))\n      } else {\n        mutator(defaultSingular || singular)\n      }\n      write(locale)\n    }\n\n    return accessor()\n  }\n\n  /**\n   * initialize the same key in all locales\n   * when not already existing, checked via translate\n   */\n  const syncToAllFiles = (singular, plural) => {\n    // iterate over locales and translate again\n    // this will implicitly write/sync missing keys\n    // to the rest of locales\n    for (const l in locales) {\n      translate(l, singular, plural, true)\n    }\n  }\n\n  /**\n   * Allows delayed access to translations nested inside objects.\n   * @param {String} locale The locale to use.\n   * @param {String} singular The singular term to look up.\n   * @param {Boolean} [allowDelayedTraversal=true] Is delayed traversal of the tree allowed?\n   * This parameter is used internally. It allows to signal the accessor that\n   * a translation was not found in the initial lookup and that an invocation\n   * of the accessor may trigger another traversal of the tree.\n   * @returns {Function} A function that, when invoked, returns the current value stored\n   * in the object at the requested location.\n   */\n  const localeAccessor = (locale, singular, allowDelayedTraversal) => {\n    // Bail out on non-existent locales to defend against internal errors.\n    if (!locales[locale]) return Function.prototype\n\n    // Handle object lookup notation\n    const indexOfDot = objectNotation && singular.lastIndexOf(objectNotation)\n    if (objectNotation && indexOfDot > 0 && indexOfDot < singular.length - 1) {\n      // If delayed traversal wasn't specifically forbidden, it is allowed.\n      if (typeof allowDelayedTraversal === 'undefined')\n        allowDelayedTraversal = true\n      // The accessor we're trying to find and which we want to return.\n      let accessor = null\n      // An accessor that returns null.\n      const nullAccessor = () => null\n      // Do we need to re-traverse the tree upon invocation of the accessor?\n      let reTraverse = false\n      // Split the provided term and run the callback for each subterm.\n      singular.split(objectNotation).reduce((object, index) => {\n        // Make the accessor return null.\n        accessor = nullAccessor\n        // If our current target object (in the locale tree) doesn't exist or\n        // it doesn't have the next subterm as a member...\n        if (\n          object === null ||\n          !Object.prototype.hasOwnProperty.call(object, index)\n        ) {\n          // ...remember that we need retraversal (because we didn't find our target).\n          reTraverse = allowDelayedTraversal\n          // Return null to avoid deeper iterations.\n          return null\n        }\n        // We can traverse deeper, so we generate an accessor for this current level.\n        accessor = () => object[index]\n        // Return a reference to the next deeper level in the locale tree.\n        return object[index]\n      }, locales[locale])\n      // Return the requested accessor.\n      return () =>\n        // If we need to re-traverse (because we didn't find our target term)\n        // traverse again and return the new result (but don't allow further iterations)\n        // or return the previously found accessor if it was already valid.\n        reTraverse ? localeAccessor(locale, singular, false)() : accessor()\n    } else {\n      // No object notation, just return an accessor that performs array lookup.\n      return () => locales[locale][singular]\n    }\n  }\n\n  /**\n   * Allows delayed mutation of a translation nested inside objects.\n   * @description Construction of the mutator will attempt to locate the requested term\n   * inside the object, but if part of the branch does not exist yet, it will not be\n   * created until the mutator is actually invoked. At that point, re-traversal of the\n   * tree is performed and missing parts along the branch will be created.\n   * @param {String} locale The locale to use.\n   * @param {String} singular The singular term to look up.\n   * @param [Boolean} [allowBranching=false] Is the mutator allowed to create previously\n   * non-existent branches along the requested locale path?\n   * @returns {Function} A function that takes one argument. When the function is\n   * invoked, the targeted translation term will be set to the given value inside the locale table.\n   */\n  const localeMutator = function (locale, singular, allowBranching) {\n    // Bail out on non-existent locales to defend against internal errors.\n    if (!locales[locale]) return Function.prototype\n\n    // Handle object lookup notation\n    const indexOfDot = objectNotation && singular.lastIndexOf(objectNotation)\n    if (objectNotation && indexOfDot > 0 && indexOfDot < singular.length - 1) {\n      // If branching wasn't specifically allowed, disable it.\n      if (typeof allowBranching === 'undefined') allowBranching = false\n      // This will become the function we want to return.\n      let accessor = null\n      // An accessor that takes one argument and returns null.\n      const nullAccessor = () => null\n      // Fix object path.\n      let fixObject = () => ({})\n      // Are we going to need to re-traverse the tree when the mutator is invoked?\n      let reTraverse = false\n      // Split the provided term and run the callback for each subterm.\n      singular.split(objectNotation).reduce((object, index) => {\n        // Make the mutator do nothing.\n        accessor = nullAccessor\n        // If our current target object (in the locale tree) doesn't exist or\n        // it doesn't have the next subterm as a member...\n        if (\n          object === null ||\n          !Object.prototype.hasOwnProperty.call(object, index)\n        ) {\n          // ...check if we're allowed to create new branches.\n          if (allowBranching) {\n            // Fix `object` if `object` is not Object.\n            if (object === null || typeof object !== 'object') {\n              object = fixObject()\n            }\n            // If we are allowed to, create a new object along the path.\n            object[index] = {}\n          } else {\n            // If we aren't allowed, remember that we need to re-traverse later on and...\n            reTraverse = true\n            // ...return null to make the next iteration bail our early on.\n            return null\n          }\n        }\n        // Generate a mutator for the current level.\n        accessor = (value) => {\n          object[index] = value\n          return value\n        }\n        // Generate a fixer for the current level.\n        fixObject = () => {\n          object[index] = {}\n          return object[index]\n        }\n\n        // Return a reference to the next deeper level in the locale tree.\n        return object[index]\n      }, locales[locale])\n\n      // Return the final mutator.\n      return (value) => {\n        // If we need to re-traverse the tree\n        // invoke the search again, but allow branching\n        // this time (because here the mutator is being invoked)\n        // otherwise, just change the value directly.\n        value = missingKeyFn(locale, value)\n        return reTraverse\n          ? localeMutator(locale, singular, true)(value)\n          : accessor(value)\n      }\n    } else {\n      // No object notation, just return a mutator that performs array lookup and changes the value.\n      return (value) => {\n        value = missingKeyFn(locale, value)\n        locales[locale][singular] = value\n        return value\n      }\n    }\n  }\n\n  /**\n   * try reading a file\n   */\n  const read = (locale) => {\n    let localeFile = {}\n    const file = getStorageFilePath(locale)\n    try {\n      logDebug('read ' + file + ' for locale: ' + locale)\n      localeFile = fs.readFileSync(file, 'utf-8')\n      try {\n        // parsing filecontents to locales[locale]\n        locales[locale] = parser.parse(localeFile)\n      } catch (parseError) {\n        logError(\n          'unable to parse locales from file (maybe ' +\n            file +\n            ' is empty or invalid json?): ',\n          parseError\n        )\n      }\n    } catch (readError) {\n      // unable to read, so intialize that file\n      // locales[locale] are already set in memory, so no extra read required\n      // or locales[locale] are empty, which initializes an empty locale.json file\n      // since the current invalid locale could exist, we should back it up\n      if (fs.existsSync(file)) {\n        logDebug(\n          'backing up invalid locale ' + locale + ' to ' + file + '.invalid'\n        )\n        fs.renameSync(file, file + '.invalid')\n      }\n\n      logDebug('initializing ' + file)\n      write(locale)\n    }\n  }\n\n  /**\n   * try writing a file in a created directory\n   */\n  const write = (locale) => {\n    let stats, target, tmp\n\n    // don't write new locale information to disk if updateFiles isn't true\n    if (!updateFiles) {\n      return\n    }\n\n    // creating directory if necessary\n    try {\n      stats = fs.lstatSync(directory)\n    } catch (e) {\n      logDebug('creating locales dir in: ' + directory)\n      try {\n        fs.mkdirSync(directory, directoryPermissions)\n      } catch (e) {\n        // in case of parallel tasks utilizing in same dir\n        if (e.code !== 'EEXIST') throw e\n      }\n    }\n\n    // first time init has an empty file\n    if (!locales[locale]) {\n      locales[locale] = {}\n    }\n\n    // writing to tmp and rename on success\n    try {\n      target = getStorageFilePath(locale)\n      tmp = target + '.tmp'\n      fs.writeFileSync(\n        tmp,\n        parser.stringify(locales[locale], null, indent),\n        'utf8'\n      )\n      stats = fs.statSync(tmp)\n      if (stats.isFile()) {\n        fs.renameSync(tmp, target)\n      } else {\n        logError(\n          'unable to write locales to file (either ' +\n            tmp +\n            ' or ' +\n            target +\n            ' are not writeable?): '\n        )\n      }\n    } catch (e) {\n      logError(\n        'unexpected error writing files (either ' +\n          tmp +\n          ' or ' +\n          target +\n          ' are not writeable?): ',\n        e\n      )\n    }\n  }\n\n  /**\n   * basic normalization of filepath\n   */\n  const getStorageFilePath = (locale) => {\n    // changed API to use .json as default, #16\n    const ext = extension || '.json'\n    const filepath = path.normalize(directory + pathsep + prefix + locale + ext)\n    const filepathJS = path.normalize(\n      directory + pathsep + prefix + locale + '.js'\n    )\n    // use .js as fallback if already existing\n    try {\n      if (fs.statSync(filepathJS)) {\n        logDebug('using existing file ' + filepathJS)\n        extension = '.js'\n        return filepathJS\n      }\n    } catch (e) {\n      logDebug('will use ' + filepath)\n    }\n    return filepath\n  }\n\n  /**\n   * Get locales with wildcard support\n   */\n  const getFallback = (targetLocale, fallbacks) => {\n    fallbacks = fallbacks || {}\n    if (fallbacks[targetLocale]) return fallbacks[targetLocale]\n    let fallBackLocale = null\n    for (const key in fallbacks) {\n      if (targetLocale.match(new RegExp('^' + key.replace('*', '.*') + '$'))) {\n        fallBackLocale = fallbacks[key]\n        break\n      }\n    }\n    return fallBackLocale\n  }\n\n  /**\n   * Logging proxies\n   */\n  const logDebug = (msg) => {\n    logDebugFn(msg)\n  }\n\n  const logWarn = (msg) => {\n    logWarnFn(msg)\n  }\n\n  const logError = (msg) => {\n    logErrorFn(msg)\n  }\n\n  /**\n   * Missing key function\n   */\n  const missingKey = (locale, value) => {\n    return value\n  }\n\n  /**\n   * implicitly configure when created with given options\n   * @example\n   * const i18n = new I18n({\n   *   locales: ['en', 'fr']\n   * });\n   */\n  if (_OPTS) i18n.configure(_OPTS)\n\n  return i18n\n}\n\nmodule.exports = i18n\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ;AACA,MAAMA,MAAM,GAAGC,OAAO,CAAC,aAAa,CAAC,CAACD,MAAM;AAC5C,MAAME,UAAU,GAAGD,OAAO,CAAC,gBAAgB,CAAC,CAACE,OAAO;AACpD,MAAMC,EAAE,GAAGH,OAAO,CAAC,IAAI,CAAC;AACxB,MAAMI,GAAG,GAAGJ,OAAO,CAAC,KAAK,CAAC;AAC1B,MAAMK,IAAI,GAAGL,OAAO,CAAC,MAAM,CAAC;AAC5B,MAAMM,KAAK,GAAGN,OAAO,CAAC,OAAO,CAAC,CAAC,YAAY,CAAC;AAC5C,MAAMO,IAAI,GAAGP,OAAO,CAAC,OAAO,CAAC,CAAC,WAAW,CAAC;AAC1C,MAAMQ,KAAK,GAAGR,OAAO,CAAC,OAAO,CAAC,CAAC,YAAY,CAAC;AAC5C,MAAMS,QAAQ,GAAGT,OAAO,CAAC,UAAU,CAAC;AACpC,MAAMU,aAAa,GAAGV,OAAO,CAAC,qBAAqB,CAAC;AACpD,MAAMW,UAAU,GAAGX,OAAO,CAAC,aAAa,CAAC;AACzC,MAAMY,aAAa,GAAGZ,OAAO,CAAC,sBAAsB,CAAC,CAACa,OAAO;;AAE7D;AACA,MAAMC,YAAY,GAAIC,MAAM,IAAKA,MAAM,CAACC,OAAO,CAAC,qBAAqB,EAAE,MAAM,CAAC,EAAC;;AAE/E;AACA;AACA;AACA,MAAMC,IAAI,GAAG,SAASC,IAAIA,CAACC,KAAK,GAAG,KAAK,EAAE;EACxC,MAAMC,8BAA8B,GAAG,CAAC,CAAC;EACzC,MAAMC,gBAAgB,GAAG,CAAC,CAAC;EAC3B,IAAIC,OAAO,GAAG,CAAC,CAAC;EAChB,MAAMC,GAAG,GAAG;IACVC,EAAE,EAAE,IAAI;IACRC,GAAG,EAAE,KAAK;IACVC,GAAG,EAAE,KAAK;IACVC,GAAG,EAAE,KAAK;IACVC,IAAI,EAAE,MAAM;IACZC,SAAS,EAAE,WAAW;IACtBC,SAAS,EAAE,WAAW;IACtBC,UAAU,EAAE,YAAY;IACxBC,UAAU,EAAE,YAAY;IACxBC,SAAS,EAAE,WAAW;IACtBC,YAAY,EAAE;EAChB,CAAC;EACD,MAAMC,cAAc,GAAG;IACrBC,IAAI,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC;IAClBC,OAAO,EAAE;EACX,CAAC;EAED,IAAIC,aAAa;EACjB,MAAMC,OAAO,GAAGlC,IAAI,CAACmC,GAAG,EAAC;EACzB,IAAIC,UAAU;EACd,IAAIC,UAAU;EACd,IAAIC,kBAAkB;EACtB,IAAIC,aAAa;EACjB,IAAIC,oBAAoB;EACxB,IAAIC,SAAS;EACb,IAAIC,oBAAoB;EACxB,IAAIC,SAAS;EACb,IAAIC,SAAS;EACb,IAAIC,MAAM;EACV,IAAIC,UAAU;EACd,IAAIC,UAAU;EACd,IAAIC,SAAS;EACb,IAAIC,kBAAkB;EACtB,IAAIC,cAAc;EAClB,IAAIC,MAAM;EACV,IAAIC,cAAc;EAClB,IAAIC,QAAQ;EACZ,IAAIC,WAAW;EACf,IAAIC,SAAS;EACb,IAAIC,YAAY;EAChB,IAAIC,MAAM;;EAEV;EACA,MAAM7C,IAAI,GAAG,CAAC,CAAC;EAEfA,IAAI,CAACf,OAAO,GAAGD,UAAU;EAEzBgB,IAAI,CAAC8C,SAAS,GAAG,SAASC,aAAaA,CAACC,GAAG,EAAE;IAC3C;IACA3C,OAAO,GAAG,CAAC,CAAC;;IAEZ;IACA;IACA,IAAI2C,GAAG,CAAC1C,GAAG,IAAI,OAAO0C,GAAG,CAAC1C,GAAG,KAAK,QAAQ,EAAE;MAC1C,KAAK,MAAM2C,MAAM,IAAID,GAAG,CAAC1C,GAAG,EAAE;QAC5B,IAAI4C,MAAM,CAACC,SAAS,CAACC,cAAc,CAACC,IAAI,CAACL,GAAG,CAAC1C,GAAG,EAAE2C,MAAM,CAAC,EAAE;UACzD,MAAMK,KAAK,GAAGN,GAAG,CAAC1C,GAAG,CAAC2C,MAAM,CAAC;UAC7B,IAAI,OAAO3C,GAAG,CAAC2C,MAAM,CAAC,KAAK,WAAW,EAAE;YACtC3C,GAAG,CAAC2C,MAAM,CAAC,GAAGK,KAAK;UACrB;QACF;MACF;IACF;;IAEA;IACA,IAAI,OAAON,GAAG,CAACP,QAAQ,KAAK,QAAQ,EAAE;MACpCA,QAAQ,GAAGO,GAAG,CAACP,QAAQ;MACvB;MACA,IAAIc,KAAK,CAACC,OAAO,CAACR,GAAG,CAACP,QAAQ,CAAC,EAAE;QAC/BA,QAAQ,GAAGO,GAAG,CAACP,QAAQ;QACvBA,QAAQ,CAACgB,OAAO,CAACC,gBAAgB,CAAC;MACpC,CAAC,MAAM;QACLA,gBAAgB,CAACV,GAAG,CAACP,QAAQ,CAAC;MAChC;IACF;;IAEA;IACAhB,UAAU,GAAG,OAAOuB,GAAG,CAACW,MAAM,KAAK,QAAQ,GAAGX,GAAG,CAACW,MAAM,GAAG,IAAI;;IAE/D;IACAjC,kBAAkB,GAChB,OAAOsB,GAAG,CAACY,MAAM,KAAK,QAAQ,GAAGZ,GAAG,CAACY,MAAM,GAAG,iBAAiB;;IAEjE;IACApB,cAAc,GACZ,OAAOQ,GAAG,CAACR,cAAc,KAAK,QAAQ,GAAGQ,GAAG,CAACR,cAAc,GAAG,IAAI;;IAEpE;IACAX,SAAS,GACP,OAAOmB,GAAG,CAACnB,SAAS,KAAK,QAAQ,GAC7BmB,GAAG,CAACnB,SAAS,GACbzC,IAAI,CAACyE,IAAI,CAACC,SAAS,EAAE,SAAS,CAAC;;IAErC;IACAhC,oBAAoB,GAClB,OAAOkB,GAAG,CAAClB,oBAAoB,KAAK,QAAQ,GACxCiC,QAAQ,CAACf,GAAG,CAAClB,oBAAoB,EAAE,CAAC,CAAC,GACrC,IAAI;;IAEV;IACAY,WAAW,GAAG,OAAOM,GAAG,CAACN,WAAW,KAAK,SAAS,GAAGM,GAAG,CAACN,WAAW,GAAG,IAAI;;IAE3E;IACAC,SAAS,GAAG,OAAOK,GAAG,CAACL,SAAS,KAAK,SAAS,GAAGK,GAAG,CAACL,SAAS,GAAG,KAAK;;IAEtE;IACAV,MAAM,GAAG,OAAOe,GAAG,CAACf,MAAM,KAAK,QAAQ,GAAGe,GAAG,CAACf,MAAM,GAAG,IAAI;;IAE3D;IACAM,MAAM,GAAG,OAAOS,GAAG,CAACT,MAAM,KAAK,QAAQ,GAAGS,GAAG,CAACT,MAAM,GAAG,EAAE;;IAEzD;IACAR,SAAS,GAAG,OAAOiB,GAAG,CAACjB,SAAS,KAAK,QAAQ,GAAGiB,GAAG,CAACjB,SAAS,GAAG,OAAO;;IAEvE;IACAJ,aAAa,GACX,OAAOqB,GAAG,CAACrB,aAAa,KAAK,QAAQ,GAAGqB,GAAG,CAACrB,aAAa,GAAG,IAAI;;IAElE;IACAC,oBAAoB,GAClB,OAAOoB,GAAG,CAACpB,oBAAoB,KAAK,SAAS,GACzCoB,GAAG,CAACpB,oBAAoB,GACxB,KAAK;;IAEX;IACAJ,UAAU,GAAG,OAAOwB,GAAG,CAACxB,UAAU,KAAK,SAAS,GAAGwB,GAAG,CAACxB,UAAU,GAAG,KAAK;;IAEzE;IACAc,cAAc,GACZ,OAAOU,GAAG,CAACV,cAAc,KAAK,WAAW,GAAGU,GAAG,CAACV,cAAc,GAAG,KAAK;IACxE,IAAIA,cAAc,KAAK,IAAI,EAAEA,cAAc,GAAG,GAAG;;IAEjD;IACAN,SAAS,GAAG,OAAOgB,GAAG,CAAChB,SAAS,KAAK,QAAQ,GAAGgB,GAAG,CAAChB,SAAS,GAAG,CAAC,CAAC;;IAElE;IACAE,UAAU,GAAG,OAAOc,GAAG,CAACd,UAAU,KAAK,UAAU,GAAGc,GAAG,CAACd,UAAU,GAAG7C,KAAK;IAC1E+C,SAAS,GAAG,OAAOY,GAAG,CAACZ,SAAS,KAAK,UAAU,GAAGY,GAAG,CAACZ,SAAS,GAAG9C,IAAI;IACtE6C,UAAU,GAAG,OAAOa,GAAG,CAACb,UAAU,KAAK,UAAU,GAAGa,GAAG,CAACb,UAAU,GAAG5C,KAAK;IAE1E8C,kBAAkB,GAChB,OAAOW,GAAG,CAACX,kBAAkB,KAAK,SAAS,GACvCW,GAAG,CAACX,kBAAkB,GACtB,IAAI;;IAEV;IACAO,YAAY,GACV,OAAOI,GAAG,CAACJ,YAAY,KAAK,UAAU,GAAGI,GAAG,CAACJ,YAAY,GAAGoB,UAAU;IAExEnB,MAAM,GACJ,OAAOG,GAAG,CAACH,MAAM,KAAK,QAAQ,IAC9B,OAAOG,GAAG,CAACH,MAAM,CAACoB,KAAK,KAAK,UAAU,IACtC,OAAOjB,GAAG,CAACH,MAAM,CAACqB,SAAS,KAAK,UAAU,GACtClB,GAAG,CAACH,MAAM,GACVsB,IAAI;;IAEV;IACAnB,GAAG,CAAC3C,OAAO,GAAG2C,GAAG,CAACoB,aAAa,GAC3BlB,MAAM,CAACmB,IAAI,CAACrB,GAAG,CAACoB,aAAa,CAAC,GAC9BpB,GAAG,CAAC3C,OAAO,IAAIiE,YAAY,CAACzC,SAAS,CAAC;;IAE1C;IACA,IAAImB,GAAG,CAACoB,aAAa,EAAE;MACrB1B,WAAW,GAAG,KAAK;MACnBlB,UAAU,GAAG,KAAK;MAClBmB,SAAS,GAAG,KAAK;IACnB;;IAEA;IACA,IAAIK,GAAG,CAAC9B,cAAc,EAAE;MACtB,IAAIqC,KAAK,CAACC,OAAO,CAACR,GAAG,CAAC9B,cAAc,CAACC,IAAI,CAAC,EAAE;QAC1CD,cAAc,CAACC,IAAI,GAAG6B,GAAG,CAAC9B,cAAc,CAACC,IAAI;MAC/C;MACA,IAAI6B,GAAG,CAAC9B,cAAc,CAACE,OAAO,KAAK,IAAI,EAAE;QACvCF,cAAc,CAACE,OAAO,GAAG,IAAI;MAC/B;IACF;IAEA,MAAM,CAACmD,KAAK,EAAEC,GAAG,CAAC,GAAGtD,cAAc,CAACC,IAAI;IACxCE,aAAa,GAAG,IAAIoD,MAAM,CAAC5E,YAAY,CAAC0E,KAAK,CAAC,GAAG,IAAI,GAAG1E,YAAY,CAAC2E,GAAG,CAAC,CAAC;;IAE1E;IACA,IAAIjB,KAAK,CAACC,OAAO,CAACR,GAAG,CAAC3C,OAAO,CAAC,EAAE;MAC9B,IAAI2C,GAAG,CAACoB,aAAa,EAAE;QACrB/D,OAAO,GAAG2C,GAAG,CAACoB,aAAa;MAC7B,CAAC,MAAM;QACLpB,GAAG,CAAC3C,OAAO,CAACoD,OAAO,CAACiB,IAAI,CAAC;MAC3B;;MAEA;MACA,IAAIlD,UAAU,EAAE;QACd;QACAtC,EAAE,CAACyF,KAAK,CAAC9C,SAAS,EAAE,CAAC+C,KAAK,EAAEC,QAAQ,KAAK;UACvC,MAAMC,cAAc,GAAGC,mBAAmB,CAACF,QAAQ,CAAC;UAEpD,IAAIC,cAAc,IAAI9B,GAAG,CAAC3C,OAAO,CAAC2E,OAAO,CAACF,cAAc,CAAC,GAAG,CAAC,CAAC,EAAE;YAC9DG,QAAQ,CAAC,8BAA8B,GAAGJ,QAAQ,GAAG,IAAI,CAAC;YAC1DH,IAAI,CAACI,cAAc,CAAC;UACtB;QACF,CAAC,CAAC;MACJ;IACF;EACF,CAAC;EAED9E,IAAI,CAACkF,IAAI,GAAG,SAASC,QAAQA,CAACC,OAAO,EAAEC,QAAQ,EAAEC,IAAI,EAAE;IACrD,IAAI,OAAOF,OAAO,KAAK,QAAQ,EAAE;MAC/B;MACAG,aAAa,CAACH,OAAO,CAAC;;MAEtB;MACA1B,gBAAgB,CAAC0B,OAAO,CAAC;;MAEzB;MACApF,IAAI,CAACa,SAAS,CAACuE,OAAO,EAAEA,OAAO,CAACI,MAAM,CAAC;IACzC,CAAC,MAAM;MACL,OAAOC,QAAQ,CACb,yEACF,CAAC;IACH;IAEA,IAAI,OAAOJ,QAAQ,KAAK,QAAQ,EAAE;MAChC3B,gBAAgB,CAAC2B,QAAQ,CAAC;;MAE1B;MACArF,IAAI,CAACa,SAAS,CAACwE,QAAQ,EAAED,OAAO,CAACI,MAAM,CAAC;IAC1C;;IAEA;IACA,IAAI,OAAOF,IAAI,KAAK,UAAU,EAAE;MAC9B,OAAOA,IAAI,CAAC,CAAC;IACf;EACF,CAAC;EAEDtF,IAAI,CAACO,EAAE,GAAG,SAASmF,aAAaA,CAACC,MAAM,EAAE;IACvC,IAAIC,GAAG;IACP,MAAMC,IAAI,GAAGC,SAAS,CAACC,SAAS,CAAC;IACjC,MAAMC,WAAW,GAAGH,IAAI,CAAC,CAAC,CAAC;IAC3B,MAAMI,IAAI,GAAGJ,IAAI,CAAC,CAAC,CAAC;;IAEpB;IACA,IAAI,OAAOF,MAAM,KAAK,QAAQ,EAAE;MAC9B,IACE,OAAOA,MAAM,CAACH,MAAM,KAAK,QAAQ,IACjC,OAAOG,MAAM,CAACA,MAAM,KAAK,QAAQ,EACjC;QACAC,GAAG,GAAGM,SAAS,CAACP,MAAM,CAACH,MAAM,EAAEG,MAAM,CAACA,MAAM,CAAC;MAC/C;IACF;IACA;IAAA,KACK;MACH;MACAC,GAAG,GAAGM,SAAS,CAACC,mBAAmB,CAAC,IAAI,CAAC,EAAER,MAAM,CAAC;IACpD;;IAEA;IACA,IAAI,OAAOC,GAAG,KAAK,QAAQ,IAAIA,GAAG,CAACQ,GAAG,EAAE;MACtCR,GAAG,GAAGA,GAAG,CAACQ,GAAG;IACf;;IAEA;IACA,IAAI,OAAOR,GAAG,KAAK,QAAQ,IAAIA,GAAG,CAACS,KAAK,EAAE;MACxCT,GAAG,GAAGA,GAAG,CAACS,KAAK;IACjB;;IAEA;IACA,OAAOC,WAAW,CAACV,GAAG,EAAEI,WAAW,EAAEC,IAAI,CAAC;EAC5C,CAAC;EAEDjG,IAAI,CAACW,IAAI,GAAG,SAAS4F,iBAAiBA,CAACZ,MAAM,EAAE;IAC7C,IAAIC,GAAG,EAAEY,EAAE,EAAEC,CAAC;IACd,IAAIC,YAAY,GAAG/E,aAAa;IAChC,MAAMkE,IAAI,GAAGC,SAAS,CAACC,SAAS,CAAC;IACjC,MAAMC,WAAW,GAAGH,IAAI,CAAC,CAAC,CAAC;IAC3B,MAAMI,IAAI,GAAGJ,IAAI,CAAC,CAAC,CAAC;;IAEpB;IACA,IAAI,OAAOF,MAAM,KAAK,QAAQ,EAAE;MAC9B,IACE,OAAOA,MAAM,CAACH,MAAM,KAAK,QAAQ,IACjC,OAAOG,MAAM,CAACA,MAAM,KAAK,QAAQ,EACjC;QACAC,GAAG,GAAGD,MAAM,CAACA,MAAM;QACnBe,YAAY,GAAGf,MAAM,CAACH,MAAM;MAC9B;IACF;IACA;IAAA,KACK;MACH;MACAI,GAAG,GAAGD,MAAM;MACZe,YAAY,GAAGP,mBAAmB,CAAC,IAAI,CAAC;IAC1C;IAEAP,GAAG,GAAGM,SAAS,CAACQ,YAAY,EAAEd,GAAG,CAAC;IAClC;;IAEA;IACA;IACA,IAAIzF,8BAA8B,CAACuG,YAAY,CAAC,EAAE;MAChDF,EAAE,GAAGrG,8BAA8B,CAACuG,YAAY,CAAC;IACnD,CAAC,MAAM;MACLF,EAAE,GAAG,IAAI/G,aAAa,CAACiH,YAAY,CAAC;MAEpCF,EAAE,CAACG,iBAAiB,GAAG,CAAC,CAAC;MACzBxG,8BAA8B,CAACuG,YAAY,CAAC,GAAGF,EAAE;IACnD;;IAEA;IACA,IAAIA,EAAE,CAACG,iBAAiB,CAACf,GAAG,CAAC,EAAE;MAC7Ba,CAAC,GAAGD,EAAE,CAACG,iBAAiB,CAACf,GAAG,CAAC;IAC/B,CAAC,MAAM;MACLa,CAAC,GAAGD,EAAE,CAACI,OAAO,CAAChB,GAAG,CAAC;MACnBY,EAAE,CAACG,iBAAiB,CAACf,GAAG,CAAC,GAAGa,CAAC;IAC/B;IAEA,OAAOH,WAAW,CAACG,CAAC,CAACT,WAAW,CAAC,EAAEA,WAAW,EAAEC,IAAI,CAAC;EACvD,CAAC;EAEDjG,IAAI,CAACS,GAAG,GAAG,SAASoG,mBAAmBA,CAAClB,MAAM,EAAE;IAC9C,MAAMmB,YAAY,GAAG,EAAE;IACvB5D,MAAM,CAACmB,IAAI,CAAChE,OAAO,CAAC,CACjB0G,IAAI,CAAC,CAAC,CACNtD,OAAO,CAAEuD,CAAC,IAAK;MACdF,YAAY,CAACG,IAAI,CAACjH,IAAI,CAACO,EAAE,CAAC;QAAEoF,MAAM,EAAEA,MAAM;QAAEH,MAAM,EAAEwB;MAAE,CAAC,CAAC,CAAC;IAC3D,CAAC,CAAC;IACJ,OAAOF,YAAY;EACrB,CAAC;EAED9G,IAAI,CAACU,GAAG,GAAG,SAASwG,mBAAmBA,CAACvB,MAAM,EAAE;IAC9C,MAAMmB,YAAY,GAAG,EAAE;IACvB5D,MAAM,CAACmB,IAAI,CAAChE,OAAO,CAAC,CACjB0G,IAAI,CAAC,CAAC,CACNtD,OAAO,CAAEuD,CAAC,IAAK;MACd,MAAMG,IAAI,GAAG,CAAC,CAAC;MACfA,IAAI,CAACH,CAAC,CAAC,GAAGhH,IAAI,CAACO,EAAE,CAAC;QAAEoF,MAAM,EAAEA,MAAM;QAAEH,MAAM,EAAEwB;MAAE,CAAC,CAAC;MAChDF,YAAY,CAACG,IAAI,CAACE,IAAI,CAAC;IACzB,CAAC,CAAC;IACJ,OAAOL,YAAY;EACrB,CAAC;EAED9G,IAAI,CAACQ,GAAG,GAAG,SAAS4G,mBAAmBA,CAACC,QAAQ,EAAEC,MAAM,EAAEC,KAAK,EAAE;IAC/D,IAAI3B,GAAG;IACP,IAAII,WAAW;IACf,IAAIU,YAAY;IAChB,IAAIT,IAAI,GAAG,EAAE;;IAEb;IACA,IAAIuB,sBAAsB,CAACzB,SAAS,CAAC,EAAE;MACrCC,WAAW,GAAGD,SAAS,CAACA,SAAS,CAAC0B,MAAM,GAAG,CAAC,CAAC;MAC7CxB,IAAI,GACFF,SAAS,CAAC0B,MAAM,IAAI,CAAC,GACjBlE,KAAK,CAACJ,SAAS,CAACuE,KAAK,CAACrE,IAAI,CAAC0C,SAAS,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,GAC5C,EAAE;IACV,CAAC,MAAM;MACLC,WAAW,GAAG,CAAC,CAAC;MAChBC,IAAI,GACFF,SAAS,CAAC0B,MAAM,IAAI,CAAC,GAAGlE,KAAK,CAACJ,SAAS,CAACuE,KAAK,CAACrE,IAAI,CAAC0C,SAAS,EAAE,CAAC,CAAC,GAAG,EAAE;IACzE;;IAEA;IACA,IAAI,OAAOsB,QAAQ,KAAK,QAAQ,EAAE;MAChC,IACE,OAAOA,QAAQ,CAAC7B,MAAM,KAAK,QAAQ,IACnC,OAAO6B,QAAQ,CAACA,QAAQ,KAAK,QAAQ,IACrC,OAAOA,QAAQ,CAACC,MAAM,KAAK,QAAQ,EACnC;QACAZ,YAAY,GAAGW,QAAQ,CAAC7B,MAAM;QAC9BI,GAAG,GAAGM,SAAS,CAACmB,QAAQ,CAAC7B,MAAM,EAAE6B,QAAQ,CAACA,QAAQ,EAAEA,QAAQ,CAACC,MAAM,CAAC;MACtE;MACArB,IAAI,CAAC0B,OAAO,CAACJ,KAAK,CAAC;;MAEnB;MACA,IAAI,OAAOD,MAAM,KAAK,QAAQ,IAAIM,MAAM,CAACN,MAAM,CAAC,GAAG,EAAE,KAAKA,MAAM,EAAE;QAChEC,KAAK,GAAGD,MAAM;MAChB;;MAEA;MACA,IACE,OAAOD,QAAQ,CAACE,KAAK,KAAK,QAAQ,IAClC,OAAOF,QAAQ,CAACE,KAAK,KAAK,QAAQ,EAClC;QACAA,KAAK,GAAGF,QAAQ,CAACE,KAAK;QACtBtB,IAAI,CAAC0B,OAAO,CAACL,MAAM,CAAC;MACtB;IACF,CAAC,MAAM;MACL;MACA,IAAI,OAAOA,MAAM,KAAK,QAAQ,IAAIM,MAAM,CAACN,MAAM,CAAC,GAAG,EAAE,KAAKA,MAAM,EAAE;QAChEC,KAAK,GAAGD,MAAM;;QAEd;QACA;QACA;QACAA,MAAM,GAAGD,QAAQ;QAEjBpB,IAAI,CAAC0B,OAAO,CAACJ,KAAK,CAAC;QACnBtB,IAAI,CAAC0B,OAAO,CAACL,MAAM,CAAC;MACtB;MACA;MACA;MACA1B,GAAG,GAAGM,SAAS,CAACC,mBAAmB,CAAC,IAAI,CAAC,EAAEkB,QAAQ,EAAEC,MAAM,CAAC;MAC5DZ,YAAY,GAAGP,mBAAmB,CAAC,IAAI,CAAC;IAC1C;IAEA,IAAIoB,KAAK,KAAK,IAAI,EAAEA,KAAK,GAAGvB,WAAW,CAACuB,KAAK;;IAE7C;IACAA,KAAK,GAAGK,MAAM,CAACL,KAAK,CAAC;;IAErB;IACA,IAAI,OAAO3B,GAAG,KAAK,QAAQ,EAAE;MAC3B,IAAIiC,CAAC;MACL;MACA;MACA,IAAIzH,gBAAgB,CAACsG,YAAY,CAAC,EAAE;QAClCmB,CAAC,GAAGzH,gBAAgB,CAACsG,YAAY,CAAC;MACpC,CAAC,MAAM;QACL;QACA,MAAMoB,EAAE,GAAGpB,YAAY,CACpBqB,WAAW,CAAC,CAAC,CACbC,KAAK,CAAC,SAAS,CAAC,CAChBC,MAAM,CAAEC,EAAE,IAAK,IAAI,IAAIA,EAAE,CAAC;QAC7B;QACAL,CAAC,GAAGnI,UAAU,CAACoI,EAAE,CAAC,CAAC,CAAC,IAAIpB,YAAY,CAAC;QACrCtG,gBAAgB,CAACsG,YAAY,CAAC,GAAGmB,CAAC;MACpC;;MAEA;MACAjC,GAAG,GAAGA,GAAG,CAACiC,CAAC,CAACN,KAAK,CAAC,CAAC,IAAI3B,GAAG,CAACS,KAAK;IAClC;;IAEA;IACA,OAAOC,WAAW,CAACV,GAAG,EAAEI,WAAW,EAAEC,IAAI,EAAEsB,KAAK,CAAC;EACnD,CAAC;EAEDvH,IAAI,CAACa,SAAS,GAAG,SAASsH,aAAaA,CAACC,MAAM,EAAE5C,MAAM,EAAE6C,mBAAmB,EAAE;IAC3E;IACA,IAAI9E,KAAK,CAACC,OAAO,CAAC4E,MAAM,CAAC,IAAI,OAAO5C,MAAM,KAAK,QAAQ,EAAE;MACvD,KAAK,IAAI8C,CAAC,GAAGF,MAAM,CAACX,MAAM,GAAG,CAAC,EAAEa,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;QAC3CtI,IAAI,CAACa,SAAS,CAACuH,MAAM,CAACE,CAAC,CAAC,EAAE9C,MAAM,EAAE,IAAI,CAAC;MACzC;MACA,OAAOxF,IAAI,CAACY,SAAS,CAACwH,MAAM,CAAC,CAAC,CAAC,CAAC;IAClC;;IAEA;IACA,IAAIG,YAAY,GAAGH,MAAM;IACzB,IAAI1B,YAAY,GAAGlB,MAAM;;IAEzB;IACA,IAAIA,MAAM,KAAKgD,SAAS,IAAI,OAAOJ,MAAM,KAAK,QAAQ,EAAE;MACtDG,YAAY,GAAG,IAAI;MACnB7B,YAAY,GAAG0B,MAAM;IACvB;;IAEA;IACA,IAAI,CAAC/H,OAAO,CAACqG,YAAY,CAAC,EAAE;MAC1BA,YAAY,GAAG+B,WAAW,CAAC/B,YAAY,EAAE1E,SAAS,CAAC,IAAI0E,YAAY;IACrE;;IAEA;IACA6B,YAAY,CAAC/C,MAAM,GAAGnF,OAAO,CAACqG,YAAY,CAAC,GAAGA,YAAY,GAAG/E,aAAa;;IAE1E;IACA,IAAI,OAAOc,QAAQ,KAAK,QAAQ,EAAE;MAChC,IAAIc,KAAK,CAACC,OAAO,CAACf,QAAQ,CAAC,IAAI,CAAC4F,mBAAmB,EAAE;QACnD5F,QAAQ,CAACgB,OAAO,CAAEiF,CAAC,IAAK;UACtBA,CAAC,CAAClD,MAAM,GAAG+C,YAAY,CAAC/C,MAAM;QAChC,CAAC,CAAC;MACJ,CAAC,MAAM;QACL/C,QAAQ,CAAC+C,MAAM,GAAG+C,YAAY,CAAC/C,MAAM;MACvC;IACF;;IAEA;IACA,IAAI+C,YAAY,CAACI,GAAG,IAAI,CAACN,mBAAmB,EAAE;MAC5C;MACA;MACA;MACA,IAAIE,YAAY,CAACI,GAAG,CAACC,MAAM,EAAE;QAC3B5I,IAAI,CAACa,SAAS,CAAC0H,YAAY,CAACI,GAAG,EAAEJ,YAAY,CAAC/C,MAAM,EAAE,IAAI,CAAC;QAC3DxF,IAAI,CAACa,SAAS,CAAC0H,YAAY,CAACI,GAAG,CAACC,MAAM,EAAEL,YAAY,CAAC/C,MAAM,EAAE,IAAI,CAAC;MACpE,CAAC,MAAM;QACLxF,IAAI,CAACa,SAAS,CAAC0H,YAAY,CAACI,GAAG,EAAEJ,YAAY,CAAC/C,MAAM,CAAC;MACvD;IACF;;IAEA;IACA,IAAI+C,YAAY,CAACK,MAAM,IAAI,CAACP,mBAAmB,EAAE;MAC/C;MACA;MACA;MACA,IAAIE,YAAY,CAACK,MAAM,CAACD,GAAG,EAAE;QAC3B3I,IAAI,CAACa,SAAS,CAAC0H,YAAY,CAACK,MAAM,EAAEL,YAAY,CAAC/C,MAAM,EAAE,IAAI,CAAC;QAC9DxF,IAAI,CAACa,SAAS,CAAC0H,YAAY,CAACK,MAAM,CAACD,GAAG,EAAEJ,YAAY,CAAC/C,MAAM,EAAE,IAAI,CAAC;MACpE,CAAC,MAAM;QACLxF,IAAI,CAACa,SAAS,CAAC0H,YAAY,CAACK,MAAM,EAAEL,YAAY,CAAC/C,MAAM,CAAC;MAC1D;IACF;IAEA,OAAOxF,IAAI,CAACY,SAAS,CAAC2H,YAAY,CAAC;EACrC,CAAC;EAEDvI,IAAI,CAACY,SAAS,GAAG,SAASiI,aAAaA,CAACzD,OAAO,EAAE;IAC/C;IACA,IAAIA,OAAO,IAAIA,OAAO,CAACI,MAAM,EAAE;MAC7B,OAAOJ,OAAO,CAACI,MAAM;IACvB;;IAEA;IACA,OAAO,IAAI,CAACA,MAAM,IAAI7D,aAAa;EACrC,CAAC;EAED3B,IAAI,CAACc,UAAU,GAAG,SAASgI,cAAcA,CAACV,MAAM,EAAE5C,MAAM,EAAE;IACxD,IAAIkB,YAAY;;IAEhB;IACA,IACE,OAAO0B,MAAM,KAAK,QAAQ,IAC1B,OAAOA,MAAM,CAAC5C,MAAM,KAAK,QAAQ,IACjCA,MAAM,KAAKgD,SAAS,EACpB;MACA9B,YAAY,GAAG0B,MAAM,CAAC5C,MAAM;IAC9B;;IAEA;IACA,IACE,CAACkB,YAAY,IACb,OAAO0B,MAAM,KAAK,QAAQ,IAC1B,OAAO5C,MAAM,KAAK,QAAQ,EAC1B;MACAkB,YAAY,GAAGlB,MAAM;IACvB;;IAEA;IACA,IAAI,CAACkB,YAAY,IAAIlB,MAAM,KAAKgD,SAAS,IAAI,OAAOJ,MAAM,KAAK,QAAQ,EAAE;MACvE1B,YAAY,GAAG0B,MAAM;IACvB;;IAEA;IACA,IACE,CAAC1B,YAAY,IACb0B,MAAM,KAAKI,SAAS,IACpBhD,MAAM,KAAKgD,SAAS,IACpB,OAAO,IAAI,CAAChD,MAAM,KAAK,QAAQ,EAC/B;MACA,IAAI/C,QAAQ,IAAIA,QAAQ,CAACsG,MAAM,EAAE;QAC/BrC,YAAY,GAAG,EAAE;MACnB,CAAC,MAAM;QACLA,YAAY,GAAG,IAAI,CAAClB,MAAM;MAC5B;IACF;;IAEA;IACA,IAAIkB,YAAY,KAAK8B,SAAS,IAAI9B,YAAY,KAAK,EAAE,EAAE;MACrD,OAAOrG,OAAO;IAChB;IAEA,IAAI,CAACA,OAAO,CAACqG,YAAY,CAAC,EAAE;MAC1BA,YAAY,GAAG+B,WAAW,CAAC/B,YAAY,EAAE1E,SAAS,CAAC,IAAI0E,YAAY;IACrE;IAEA,IAAIrG,OAAO,CAACqG,YAAY,CAAC,EAAE;MACzB,OAAOrG,OAAO,CAACqG,YAAY,CAAC;IAC9B,CAAC,MAAM;MACLsC,OAAO,CAAC,wBAAwB,GAAGtC,YAAY,GAAG,GAAG,CAAC;MACtD,OAAO,KAAK;IACd;EACF,CAAC;EAED1G,IAAI,CAACe,UAAU,GAAG,SAASkI,cAAcA,CAAA,EAAG;IAC1C,OAAO/F,MAAM,CAACmB,IAAI,CAAChE,OAAO,CAAC;EAC7B,CAAC;EAEDL,IAAI,CAACgB,SAAS,GAAG,SAASkI,aAAaA,CAAC1D,MAAM,EAAE;IAC9Cd,IAAI,CAACc,MAAM,CAAC;EACd,CAAC;EAEDxF,IAAI,CAACiB,YAAY,GAAG,SAASkI,gBAAgBA,CAAC3D,MAAM,EAAE;IACpD,OAAOnF,OAAO,CAACmF,MAAM,CAAC;EACxB,CAAC;;EAED;EACA;EACA;;EAEA,MAAMc,WAAW,GAAGA,CAACV,GAAG,EAAEI,WAAW,EAAEC,IAAI,EAAEsB,KAAK,KAAK;IACrD;IACA,IAAI,IAAI,CAAC6B,IAAI,CAACxD,GAAG,CAAC,EAAE;MAClBA,GAAG,GAAGyD,mBAAmB,CAACzD,GAAG,EAAE2B,KAAK,CAAC;IACvC;;IAEA;IACA,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;MAC7B3B,GAAG,GAAG9G,MAAM,CAAC8G,GAAG,EAAEgC,MAAM,CAACL,KAAK,CAAC,CAAC;IAClC;;IAEA;IACA,IAAI,CAACrG,cAAc,CAACE,OAAO,IAAIC,aAAa,CAAC+H,IAAI,CAACxD,GAAG,CAAC,EAAE;MACtDA,GAAG,GAAGpG,QAAQ,CAAC8J,MAAM,CAAC1D,GAAG,EAAEI,WAAW,EAAE,CAAC,CAAC,EAAE9E,cAAc,CAACC,IAAI,CAAC;IAClE;;IAEA;IACA;IACA,IAAI,GAAG,CAACiI,IAAI,CAACxD,GAAG,CAAC,IAAIK,IAAI,IAAIA,IAAI,CAACwB,MAAM,GAAG,CAAC,EAAE;MAC5C7B,GAAG,GAAG9G,MAAM,CAAC8G,GAAG,EAAE,GAAGK,IAAI,CAAC;IAC5B;IAEA,OAAOL,GAAG;EACZ,CAAC;EAED,MAAM4B,sBAAsB,GAAIvB,IAAI,IAClCA,IAAI,CAACwB,MAAM,GAAG,CAAC,IACfxB,IAAI,CAACA,IAAI,CAACwB,MAAM,GAAG,CAAC,CAAC,KAAK,IAAI,IAC9B,OAAOxB,IAAI,CAACA,IAAI,CAACwB,MAAM,GAAG,CAAC,CAAC,KAAK,QAAQ;EAE3C,MAAM3B,SAAS,GAAIG,IAAI,IAAK;IAC1B,IAAID,WAAW,EAAEuD,UAAU;IAE3B,IAAI/B,sBAAsB,CAACvB,IAAI,CAAC,EAAE;MAChCD,WAAW,GAAGC,IAAI,CAACA,IAAI,CAACwB,MAAM,GAAG,CAAC,CAAC;MACnC8B,UAAU,GAAGhG,KAAK,CAACJ,SAAS,CAACuE,KAAK,CAACrE,IAAI,CAAC4C,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;IACtD,CAAC,MAAM;MACLD,WAAW,GAAG,CAAC,CAAC;MAChBuD,UAAU,GAAGtD,IAAI,CAACwB,MAAM,IAAI,CAAC,GAAGlE,KAAK,CAACJ,SAAS,CAACuE,KAAK,CAACrE,IAAI,CAAC4C,IAAI,EAAE,CAAC,CAAC,GAAG,EAAE;IAC1E;IAEA,OAAO,CAACD,WAAW,EAAEuD,UAAU,CAAC;EAClC,CAAC;;EAED;AACF;AACA;EACE,MAAM7F,gBAAgB,GAAI0E,MAAM,IAAK;IACnC,IAAIoB,aAAa,GAAG,IAAI;;IAExB;IACA,KAAK,MAAMvG,MAAM,IAAI3C,GAAG,EAAE;MACxB,IAAI4C,MAAM,CAACC,SAAS,CAACC,cAAc,CAACC,IAAI,CAAC/C,GAAG,EAAE2C,MAAM,CAAC,EAAE;QACrD,MAAMK,KAAK,GAAGhD,GAAG,CAAC2C,MAAM,CAAC;;QAEzB;QACA,IAAI,CAACmF,MAAM,CAAC9E,KAAK,CAAC,EAAE;UAClBkG,aAAa,GAAG,KAAK;UACrBpB,MAAM,CAAC9E,KAAK,CAAC,GAAGtD,IAAI,CAACiD,MAAM,CAAC,CAACwG,IAAI,CAACrB,MAAM,CAAC;QAC3C;MACF;IACF;;IAEA;IACA,IAAI,CAACA,MAAM,CAAC5C,MAAM,EAAE;MAClB4C,MAAM,CAAC5C,MAAM,GAAG7D,aAAa;IAC/B;;IAEA;IACA,IAAI6H,aAAa,EAAE;MACjB;IACF;;IAEA;IACA,IAAIpB,MAAM,CAACO,GAAG,EAAE;MACdjF,gBAAgB,CAAC0E,MAAM,CAACO,GAAG,CAAC;IAC9B;;IAEA;IACA,IAAIP,MAAM,CAACQ,MAAM,EAAE;MACjBlF,gBAAgB,CAAC0E,MAAM,CAACQ,MAAM,CAAC;IACjC;EACF,CAAC;;EAED;AACF;AACA;EACE,MAAMtE,YAAY,GAAIzC,SAAS,IAAK;IAClC,MAAM6H,OAAO,GAAGxK,EAAE,CAACyK,WAAW,CAAC9H,SAAS,CAAC;IACzC,MAAM+H,YAAY,GAAG,EAAE;IAEvB,KAAK,IAAItB,CAAC,GAAGoB,OAAO,CAACjC,MAAM,GAAG,CAAC,EAAEa,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MAC5C,IAAIoB,OAAO,CAACpB,CAAC,CAAC,CAACuB,KAAK,CAAC,KAAK,CAAC,EAAE;MAC7B,MAAM/E,cAAc,GAAGC,mBAAmB,CAAC2E,OAAO,CAACpB,CAAC,CAAC,CAAC;MACtD,IAAIxD,cAAc,EAAE8E,YAAY,CAAC3C,IAAI,CAACnC,cAAc,CAAC;IACvD;IAEA,OAAO8E,YAAY,CAAC7C,IAAI,CAAC,CAAC;EAC5B,CAAC;;EAED;AACF;AACA;EACE,MAAMhC,mBAAmB,GAAIF,QAAQ,IAAK;IACxC,MAAMiF,cAAc,GAAG,IAAIrF,MAAM,CAAC1C,SAAS,GAAG,GAAG,EAAE,GAAG,CAAC;IACvD,MAAMgI,WAAW,GAAG,IAAItF,MAAM,CAAC,GAAG,GAAGlC,MAAM,EAAE,GAAG,CAAC;IAEjD,IAAI,CAACsC,QAAQ,EAAE,OAAO,KAAK;IAC3B,IAAItC,MAAM,IAAI,CAACsC,QAAQ,CAACgF,KAAK,CAACE,WAAW,CAAC,EAAE,OAAO,KAAK;IACxD,IAAIhI,SAAS,IAAI,CAAC8C,QAAQ,CAACgF,KAAK,CAACC,cAAc,CAAC,EAAE,OAAO,KAAK;IAC9D,OAAOjF,QAAQ,CAAC9E,OAAO,CAACwC,MAAM,EAAE,EAAE,CAAC,CAACxC,OAAO,CAAC+J,cAAc,EAAE,EAAE,CAAC;EACjE,CAAC;;EAED;AACF;AACA;AACA;EACE,MAAME,oBAAoB,GAAIC,aAAa,IAAK;IAC9C,IAAI1G,KAAK,CAACC,OAAO,CAACyG,aAAa,CAAC,EAAE;MAChC,OAAOA,aAAa,CAACC,IAAI,CAAEC,IAAI,IAAKA,IAAI,KAAK,EAAE,IAAIA,IAAI,CAAC;IAC1D;IACA,OAAO,OAAOF,aAAa,KAAK,QAAQ,IAAIA,aAAa;EAC3D,CAAC;;EAED;AACF;AACA;;EAEE,MAAM1E,aAAa,GAAIH,OAAO,IAAK;IACjC,IAAI,OAAOA,OAAO,KAAK,QAAQ,EAAE;MAC/B,MAAMgF,cAAc,GAAGhF,OAAO,CAACiF,OAAO,GAClCjF,OAAO,CAACiF,OAAO,CAAC3I,kBAAkB,CAAC,GACnC8G,SAAS;MACb,MAAM8B,SAAS,GAAG,EAAE;MACpB,MAAMC,OAAO,GAAG,EAAE;MAElBnF,OAAO,CAACkF,SAAS,GAAG,CAAC3I,aAAa,CAAC;MACnCyD,OAAO,CAACmF,OAAO,GAAG,CAAC5I,aAAa,CAAC;MACjCyD,OAAO,CAACoF,QAAQ,GAAG7I,aAAa;MAChCyD,OAAO,CAACqF,MAAM,GAAG9I,aAAa;;MAE9B;MACA,IAAIa,cAAc,IAAI4C,OAAO,CAACjG,GAAG,EAAE;QACjC,MAAMuL,WAAW,GACf,OAAOtF,OAAO,CAACjG,GAAG,KAAK,QAAQ,GAAGiG,OAAO,CAACjG,GAAG,GAAGiG,OAAO,CAACjG,GAAG,CAACwL,QAAQ,CAAC,CAAC;;QAExE;AACR;AACA;AACA;QACQ;QACA,MAAMC,MAAM,GAAGzL,GAAG,CAAC8E,KAAK,CAACyG,WAAW,EAAE,IAAI,CAAC;QAC3C,MAAMG,sBAAsB,GAAGD,MAAM,CAACE,KAAK,CAACtI,cAAc,CAAC;QAC3D,IAAIqI,sBAAsB,EAAE;UAC1B,IAAIZ,aAAa,GAAGD,oBAAoB,CAACa,sBAAsB,CAAC;UAChE,IAAIZ,aAAa,EAAE;YACjBhF,QAAQ,CAAC,gCAAgC,GAAGgF,aAAa,CAAC;YAC1D,IAAI5H,kBAAkB,EAAE;cACtB4H,aAAa,GAAGA,aAAa,CAAClC,WAAW,CAAC,CAAC;YAC7C;YACA,OAAO/H,IAAI,CAACa,SAAS,CAACuE,OAAO,EAAE6E,aAAa,CAAC;UAC/C;QACF;MACF;;MAEA;MACA,IAAIxI,UAAU,IAAI2D,OAAO,CAAC2F,OAAO,IAAI3F,OAAO,CAAC2F,OAAO,CAACtJ,UAAU,CAAC,EAAE;QAChE2D,OAAO,CAACoF,QAAQ,GAAGpF,OAAO,CAAC2F,OAAO,CAACtJ,UAAU,CAAC;QAC9C,OAAOzB,IAAI,CAACa,SAAS,CAACuE,OAAO,EAAEA,OAAO,CAACoF,QAAQ,CAAC;MAClD;;MAEA;MACA,IAAIJ,cAAc,EAAE;QAClB,MAAMY,iBAAiB,GAAGC,8BAA8B,CAACb,cAAc,CAAC;QACxE,IAAIP,KAAK;QACT,IAAIqB,aAAa;QACjB,IAAIC,QAAQ;QACZ,KAAK,IAAI7C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG0C,iBAAiB,CAACvD,MAAM,EAAEa,CAAC,EAAE,EAAE;UACjD,MAAM6B,IAAI,GAAGa,iBAAiB,CAAC1C,CAAC,CAAC;UACjC,MAAM8C,EAAE,GAAGjB,IAAI,CAACnC,KAAK,CAAC,GAAG,EAAE,CAAC,CAAC;UAC7B,MAAMqD,UAAU,GAAGD,EAAE,CAAC,CAAC,CAAC;UACxB,MAAMX,MAAM,GAAGW,EAAE,CAAC,CAAC,CAAC;;UAEpB;UACA,MAAME,YAAY,GAAG7C,WAAW,CAAC0B,IAAI,EAAEnI,SAAS,CAAC;UACjD,IAAIsJ,YAAY,EAAE;YAChBH,QAAQ,GAAGG,YAAY;YACvB;YACA;YACA,MAAMC,qBAAqB,GAAGP,iBAAiB,CAAChG,OAAO,CAACmF,IAAI,CAAC;YAC7D,MAAMqB,aAAa,GAAGR,iBAAiB,CAAChG,OAAO,CAACmG,QAAQ,CAAC;YACzD,IAAIK,aAAa,GAAG,CAAC,CAAC,EAAE;cACtBR,iBAAiB,CAACS,MAAM,CAACD,aAAa,EAAE,CAAC,CAAC;YAC5C;YACAR,iBAAiB,CAACS,MAAM,CAACF,qBAAqB,GAAG,CAAC,EAAE,CAAC,EAAEJ,QAAQ,CAAC;UAClE;;UAEA;UACA,MAAMO,kBAAkB,GAAGjD,WAAW,CAAC4C,UAAU,EAAErJ,SAAS,CAAC;UAC7D,IAAI0J,kBAAkB,EAAE;YACtBP,QAAQ,GAAGO,kBAAkB;YAC7B;YACA;YACA;YACA,IAAIV,iBAAiB,CAAChG,OAAO,CAACmG,QAAQ,CAAC,GAAG,CAAC,EAAE;cAC3CH,iBAAiB,CAAC/D,IAAI,CAACkE,QAAQ,CAAC;YAClC;UACF;UAEA,IAAIb,SAAS,CAACtF,OAAO,CAACqG,UAAU,CAAC,GAAG,CAAC,EAAE;YACrCf,SAAS,CAACrD,IAAI,CAACoE,UAAU,CAACtD,WAAW,CAAC,CAAC,CAAC;UAC1C;UACA,IAAI0C,MAAM,EAAE;YACVF,OAAO,CAACtD,IAAI,CAACwD,MAAM,CAAC1C,WAAW,CAAC,CAAC,CAAC;UACpC;UAEA,IAAI,CAAC8B,KAAK,IAAIxJ,OAAO,CAAC8J,IAAI,CAAC,EAAE;YAC3BN,KAAK,GAAGM,IAAI;YACZ;UACF;UAEA,IAAI,CAACe,aAAa,IAAI7K,OAAO,CAACgL,UAAU,CAAC,EAAE;YACzCH,aAAa,GAAGG,UAAU;UAC5B;QACF;QAEAjG,OAAO,CAACoF,QAAQ,GAAGX,KAAK,IAAIqB,aAAa,IAAI9F,OAAO,CAACoF,QAAQ;QAC7DpF,OAAO,CAACqF,MAAM,GAAGF,OAAO,CAAC,CAAC,CAAC,IAAInF,OAAO,CAACqF,MAAM;QAC7C,OAAOzK,IAAI,CAACa,SAAS,CAACuE,OAAO,EAAEA,OAAO,CAACoF,QAAQ,CAAC;MAClD;IACF;;IAEA;IACA,OAAOxK,IAAI,CAACa,SAAS,CAACuE,OAAO,EAAEzD,aAAa,CAAC;EAC/C,CAAC;;EAED;AACF;AACA;EACE,MAAMsJ,8BAA8B,GAAIrH,MAAM,IAAK;IACjD,MAAM0G,SAAS,GAAG1G,MAAM,CAACoE,KAAK,CAAC,GAAG,CAAC;IACnC,MAAM2D,WAAW,GAAG,CAAC,CAAC;IACtB,OAAOrB,SAAS,CACbsB,GAAG,CAAEC,IAAI,IAAK;MACb,MAAMC,eAAe,GAAGD,IAAI,CAACE,IAAI,CAAC,CAAC,CAAC/D,KAAK,CAAC,KAAK,CAAC;MAChD,IAAI8D,eAAe,CAACrE,MAAM,GAAG,CAAC,EAAE;QAC9BqE,eAAe,CAAC,CAAC,CAAC,GAAG,GAAG;MAC1B,CAAC,MAAM;QACL,MAAME,OAAO,GAAGC,UAAU,CAACH,eAAe,CAAC,CAAC,CAAC,CAAC;QAC9CA,eAAe,CAAC,CAAC,CAAC,GAAGE,OAAO,IAAI,GAAG;MACrC;MACAL,WAAW,CAACG,eAAe,CAAC,CAAC,CAAC,CAAC,GAAGA,eAAe,CAAC,CAAC,CAAC;MAEpD,OAAOA,eAAe,CAAC,CAAC,CAAC;IAC3B,CAAC,CAAC,CACD7D,MAAM,CAAEkC,IAAI,IAAKwB,WAAW,CAACxB,IAAI,CAAC,GAAG,CAAC,CAAC,CACvCpD,IAAI,CAAC,CAACmF,CAAC,EAAEC,CAAC,KAAKR,WAAW,CAACQ,CAAC,CAAC,GAAGR,WAAW,CAACO,CAAC,CAAC,CAAC;EACpD,CAAC;;EAED;AACF;AACA;;EAEE,MAAM/F,mBAAmB,GAAIiG,GAAG,IAAK;IACnC,IAAI5G,MAAM;IACV,IAAI4G,GAAG,IAAIA,GAAG,CAACC,KAAK,EAAE;MACpB7G,MAAM,GAAG4G,GAAG,CAACC,KAAK,CAAC7G,MAAM;IAC3B;IACA,IAAI4G,GAAG,IAAIA,GAAG,CAAC5G,MAAM,EAAE;MACrBA,MAAM,GAAG4G,GAAG,CAAC5G,MAAM;IACrB;IACA,OAAOA,MAAM;EACf,CAAC;;EAED;AACF;AACA;EACE,MAAM6D,mBAAmB,GAAGA,CAAC1D,MAAM,EAAE4B,KAAK,KAAK;IAC7C,IAAI+E,YAAY,GAAG3G,MAAM;IACzB,MAAM4G,OAAO,GAAG5G,MAAM,CAACqC,KAAK,CAAC,IAAI,CAAC;IAClC,IAAIwE,kBAAkB,GAAG,KAAK;;IAE9B;IACAD,OAAO,CAACE,IAAI,CAAE5E,CAAC,IAAK;MAClB,MAAM6E,OAAO,GAAG7E,CAAC,CAACgC,KAAK,CAAC,uCAAuC,CAAC;;MAEhE;MACA,IAAI6C,OAAO,IAAI,IAAI,IAAIA,OAAO,CAAC,CAAC,CAAC,EAAE;QACjCF,kBAAkB,GAAG,IAAI;QACzB,IAAIG,aAAa,CAACpF,KAAK,EAAEmF,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE;UAC7CJ,YAAY,GAAGI,OAAO,CAAC,CAAC,CAAC;UACzB,OAAO,IAAI;QACb;MACF,CAAC,MAAM;QACL;QACA,IAAIF,kBAAkB,EAAE;UACtBF,YAAY,GAAGzE,CAAC;QAClB;MACF;MACA,OAAO,KAAK;IACd,CAAC,CAAC;IACF,OAAOyE,YAAY;EACrB,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAMK,aAAa,GAAGA,CAACC,MAAM,EAAEC,QAAQ,KAAK;IAC1CA,QAAQ,GAAGlN,aAAa,CAACkN,QAAQ,CAAC;IAClC,IAAIA,QAAQ,IAAI,OAAOD,MAAM,KAAK,QAAQ,EAAE;MAC1C,IAAIC,QAAQ,CAACC,IAAI,CAACC,KAAK,KAAKH,MAAM,EAAE;QAClC,OAAOC,QAAQ,CAACC,IAAI,CAACE,QAAQ;MAC/B;MACA,IAAIH,QAAQ,CAACI,EAAE,CAACF,KAAK,KAAKH,MAAM,EAAE;QAChC,OAAOC,QAAQ,CAACI,EAAE,CAACD,QAAQ;MAC7B;MAEA,OACEE,IAAI,CAACC,GAAG,CAACN,QAAQ,CAACC,IAAI,CAACC,KAAK,EAAEH,MAAM,CAAC,KAAKC,QAAQ,CAACC,IAAI,CAACC,KAAK,IAC7DG,IAAI,CAACE,GAAG,CAACP,QAAQ,CAACI,EAAE,CAACF,KAAK,EAAEH,MAAM,CAAC,KAAKC,QAAQ,CAACI,EAAE,CAACF,KAAK;IAE7D;IACA,OAAO,KAAK;EACd,CAAC;;EAED;AACF;AACA;EACE,MAAM7G,SAAS,GAAGA,CAACV,MAAM,EAAE6B,QAAQ,EAAEC,MAAM,EAAE+F,kBAAkB,KAAK;IAClE;IACA,IAAI,CAACA,kBAAkB,IAAI1K,SAAS,EAAE;MACpC2K,cAAc,CAACjG,QAAQ,EAAEC,MAAM,CAAC;IAClC;IAEA,IAAI9B,MAAM,KAAKgD,SAAS,EAAE;MACxBQ,OAAO,CACL,uEAAuE,GACrErH,aAAa,GACb,oBACJ,CAAC;MACD6D,MAAM,GAAG7D,aAAa;IACxB;;IAEA;IACA,IAAI,CAACtB,OAAO,CAACmF,MAAM,CAAC,EAAE;MACpBA,MAAM,GAAGiD,WAAW,CAACjD,MAAM,EAAExD,SAAS,CAAC,IAAIwD,MAAM;IACnD;;IAEA;IACA,IAAI,CAACnF,OAAO,CAACmF,MAAM,CAAC,EAAE;MACpBd,IAAI,CAACc,MAAM,CAAC;IACd;;IAEA;IACA,IAAI,CAACnF,OAAO,CAACmF,MAAM,CAAC,EAAE;MACpBwD,OAAO,CACL,eAAe,GACbxD,MAAM,GACN,kEAAkE,GAClE7D,aAAa,GACb,8BACJ,CAAC;MAED6D,MAAM,GAAG7D,aAAa;MACtB+C,IAAI,CAACc,MAAM,CAAC;IACd;;IAEA;IACA,IAAI+H,eAAe,GAAGlG,QAAQ;IAC9B,IAAImG,aAAa,GAAGlG,MAAM;IAC1B,IAAIhF,cAAc,EAAE;MAClB,IAAImL,YAAY,GAAGpG,QAAQ,CAACrC,OAAO,CAAC,GAAG,CAAC;MACxC;MACA;MACA,IAAIyI,YAAY,GAAG,CAAC,EAAE;QACpBF,eAAe,GAAGlG,QAAQ,CAACqG,SAAS,CAACD,YAAY,GAAG,CAAC,CAAC;QACtDpG,QAAQ,GAAGA,QAAQ,CAACqG,SAAS,CAAC,CAAC,EAAED,YAAY,CAAC;MAChD;MACA,IAAInG,MAAM,IAAI,OAAOA,MAAM,KAAK,QAAQ,EAAE;QACxCmG,YAAY,GAAGnG,MAAM,CAACtC,OAAO,CAAC,GAAG,CAAC;QAClC,IAAIyI,YAAY,GAAG,CAAC,EAAE;UACpBD,aAAa,GAAGlG,MAAM,CAACoG,SAAS,CAACD,YAAY,GAAG,CAAC,CAAC;UAClDnG,MAAM,GAAGA,MAAM,CAACoG,SAAS,CAAC,CAAC,EAAED,YAAY,CAAC;QAC5C;MACF;IACF;IAEA,MAAME,QAAQ,GAAGC,cAAc,CAACpI,MAAM,EAAE6B,QAAQ,CAAC;IACjD,MAAMwG,OAAO,GAAGC,aAAa,CAACtI,MAAM,EAAE6B,QAAQ,CAAC;;IAE/C;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAIC,MAAM,EAAE;MACV,IAAIqG,QAAQ,CAAC,CAAC,IAAI,IAAI,EAAE;QACtB;QACA,IAAI/L,oBAAoB,IAAI4D,MAAM,KAAK7D,aAAa,EAAE;UACpDsD,QAAQ,CACN,UAAU,GACRoC,QAAQ,GACR,MAAM,GACN7B,MAAM,GACN,eAAe,GACf7D,aACJ,CAAC;UACDkM,OAAO,CAAC3H,SAAS,CAACvE,aAAa,EAAE0F,QAAQ,EAAEC,MAAM,EAAE,IAAI,CAAC,CAAC;QAC3D,CAAC,MAAM;UACLuG,OAAO,CAAC;YACNzH,GAAG,EAAEmH,eAAe,IAAIlG,QAAQ;YAChChB,KAAK,EAAEmH,aAAa,IAAIlG;UAC1B,CAAC,CAAC;QACJ;QACAyG,KAAK,CAACvI,MAAM,CAAC;MACf;IACF;IAEA,IAAImI,QAAQ,CAAC,CAAC,IAAI,IAAI,EAAE;MACtB;MACA,IAAI/L,oBAAoB,IAAI4D,MAAM,KAAK7D,aAAa,EAAE;QACpDsD,QAAQ,CACN,UAAU,GACRoC,QAAQ,GACR,MAAM,GACN7B,MAAM,GACN,eAAe,GACf7D,aACJ,CAAC;QACDkM,OAAO,CAAC3H,SAAS,CAACvE,aAAa,EAAE0F,QAAQ,EAAEC,MAAM,EAAE,IAAI,CAAC,CAAC;MAC3D,CAAC,MAAM;QACLuG,OAAO,CAACN,eAAe,IAAIlG,QAAQ,CAAC;MACtC;MACA0G,KAAK,CAACvI,MAAM,CAAC;IACf;IAEA,OAAOmI,QAAQ,CAAC,CAAC;EACnB,CAAC;;EAED;AACF;AACA;AACA;EACE,MAAML,cAAc,GAAGA,CAACjG,QAAQ,EAAEC,MAAM,KAAK;IAC3C;IACA;IACA;IACA,KAAK,MAAMN,CAAC,IAAI3G,OAAO,EAAE;MACvB6F,SAAS,CAACc,CAAC,EAAEK,QAAQ,EAAEC,MAAM,EAAE,IAAI,CAAC;IACtC;EACF,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAMsG,cAAc,GAAGA,CAACpI,MAAM,EAAE6B,QAAQ,EAAE2G,qBAAqB,KAAK;IAClE;IACA,IAAI,CAAC3N,OAAO,CAACmF,MAAM,CAAC,EAAE,OAAOyI,QAAQ,CAAC9K,SAAS;;IAE/C;IACA,MAAM+K,UAAU,GAAG5L,cAAc,IAAI+E,QAAQ,CAAC8G,WAAW,CAAC7L,cAAc,CAAC;IACzE,IAAIA,cAAc,IAAI4L,UAAU,GAAG,CAAC,IAAIA,UAAU,GAAG7G,QAAQ,CAACI,MAAM,GAAG,CAAC,EAAE;MACxE;MACA,IAAI,OAAOuG,qBAAqB,KAAK,WAAW,EAC9CA,qBAAqB,GAAG,IAAI;MAC9B;MACA,IAAIL,QAAQ,GAAG,IAAI;MACnB;MACA,MAAMS,YAAY,GAAGA,CAAA,KAAM,IAAI;MAC/B;MACA,IAAIC,UAAU,GAAG,KAAK;MACtB;MACAhH,QAAQ,CAACW,KAAK,CAAC1F,cAAc,CAAC,CAACgM,MAAM,CAAC,CAAClG,MAAM,EAAEmG,KAAK,KAAK;QACvD;QACAZ,QAAQ,GAAGS,YAAY;QACvB;QACA;QACA,IACEhG,MAAM,KAAK,IAAI,IACf,CAAClF,MAAM,CAACC,SAAS,CAACC,cAAc,CAACC,IAAI,CAAC+E,MAAM,EAAEmG,KAAK,CAAC,EACpD;UACA;UACAF,UAAU,GAAGL,qBAAqB;UAClC;UACA,OAAO,IAAI;QACb;QACA;QACAL,QAAQ,GAAGA,CAAA,KAAMvF,MAAM,CAACmG,KAAK,CAAC;QAC9B;QACA,OAAOnG,MAAM,CAACmG,KAAK,CAAC;MACtB,CAAC,EAAElO,OAAO,CAACmF,MAAM,CAAC,CAAC;MACnB;MACA,OAAO;MACL;MACA;MACA;MACA6I,UAAU,GAAGT,cAAc,CAACpI,MAAM,EAAE6B,QAAQ,EAAE,KAAK,CAAC,CAAC,CAAC,GAAGsG,QAAQ,CAAC,CAAC;IACvE,CAAC,MAAM;MACL;MACA,OAAO,MAAMtN,OAAO,CAACmF,MAAM,CAAC,CAAC6B,QAAQ,CAAC;IACxC;EACF,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAMyG,aAAa,GAAG,SAAAA,CAAUtI,MAAM,EAAE6B,QAAQ,EAAEmH,cAAc,EAAE;IAChE;IACA,IAAI,CAACnO,OAAO,CAACmF,MAAM,CAAC,EAAE,OAAOyI,QAAQ,CAAC9K,SAAS;;IAE/C;IACA,MAAM+K,UAAU,GAAG5L,cAAc,IAAI+E,QAAQ,CAAC8G,WAAW,CAAC7L,cAAc,CAAC;IACzE,IAAIA,cAAc,IAAI4L,UAAU,GAAG,CAAC,IAAIA,UAAU,GAAG7G,QAAQ,CAACI,MAAM,GAAG,CAAC,EAAE;MACxE;MACA,IAAI,OAAO+G,cAAc,KAAK,WAAW,EAAEA,cAAc,GAAG,KAAK;MACjE;MACA,IAAIb,QAAQ,GAAG,IAAI;MACnB;MACA,MAAMS,YAAY,GAAGA,CAAA,KAAM,IAAI;MAC/B;MACA,IAAIK,SAAS,GAAGA,CAAA,MAAO,CAAC,CAAC,CAAC;MAC1B;MACA,IAAIJ,UAAU,GAAG,KAAK;MACtB;MACAhH,QAAQ,CAACW,KAAK,CAAC1F,cAAc,CAAC,CAACgM,MAAM,CAAC,CAAClG,MAAM,EAAEmG,KAAK,KAAK;QACvD;QACAZ,QAAQ,GAAGS,YAAY;QACvB;QACA;QACA,IACEhG,MAAM,KAAK,IAAI,IACf,CAAClF,MAAM,CAACC,SAAS,CAACC,cAAc,CAACC,IAAI,CAAC+E,MAAM,EAAEmG,KAAK,CAAC,EACpD;UACA;UACA,IAAIC,cAAc,EAAE;YAClB;YACA,IAAIpG,MAAM,KAAK,IAAI,IAAI,OAAOA,MAAM,KAAK,QAAQ,EAAE;cACjDA,MAAM,GAAGqG,SAAS,CAAC,CAAC;YACtB;YACA;YACArG,MAAM,CAACmG,KAAK,CAAC,GAAG,CAAC,CAAC;UACpB,CAAC,MAAM;YACL;YACAF,UAAU,GAAG,IAAI;YACjB;YACA,OAAO,IAAI;UACb;QACF;QACA;QACAV,QAAQ,GAAIZ,KAAK,IAAK;UACpB3E,MAAM,CAACmG,KAAK,CAAC,GAAGxB,KAAK;UACrB,OAAOA,KAAK;QACd,CAAC;QACD;QACA0B,SAAS,GAAGA,CAAA,KAAM;UAChBrG,MAAM,CAACmG,KAAK,CAAC,GAAG,CAAC,CAAC;UAClB,OAAOnG,MAAM,CAACmG,KAAK,CAAC;QACtB,CAAC;;QAED;QACA,OAAOnG,MAAM,CAACmG,KAAK,CAAC;MACtB,CAAC,EAAElO,OAAO,CAACmF,MAAM,CAAC,CAAC;;MAEnB;MACA,OAAQuH,KAAK,IAAK;QAChB;QACA;QACA;QACA;QACAA,KAAK,GAAGnK,YAAY,CAAC4C,MAAM,EAAEuH,KAAK,CAAC;QACnC,OAAOsB,UAAU,GACbP,aAAa,CAACtI,MAAM,EAAE6B,QAAQ,EAAE,IAAI,CAAC,CAAC0F,KAAK,CAAC,GAC5CY,QAAQ,CAACZ,KAAK,CAAC;MACrB,CAAC;IACH,CAAC,MAAM;MACL;MACA,OAAQA,KAAK,IAAK;QAChBA,KAAK,GAAGnK,YAAY,CAAC4C,MAAM,EAAEuH,KAAK,CAAC;QACnC1M,OAAO,CAACmF,MAAM,CAAC,CAAC6B,QAAQ,CAAC,GAAG0F,KAAK;QACjC,OAAOA,KAAK;MACd,CAAC;IACH;EACF,CAAC;;EAED;AACF;AACA;EACE,MAAMrI,IAAI,GAAIc,MAAM,IAAK;IACvB,IAAIkJ,UAAU,GAAG,CAAC,CAAC;IACnB,MAAMC,IAAI,GAAGC,kBAAkB,CAACpJ,MAAM,CAAC;IACvC,IAAI;MACFP,QAAQ,CAAC,OAAO,GAAG0J,IAAI,GAAG,eAAe,GAAGnJ,MAAM,CAAC;MACnDkJ,UAAU,GAAGxP,EAAE,CAAC2P,YAAY,CAACF,IAAI,EAAE,OAAO,CAAC;MAC3C,IAAI;QACF;QACAtO,OAAO,CAACmF,MAAM,CAAC,GAAG3C,MAAM,CAACoB,KAAK,CAACyK,UAAU,CAAC;MAC5C,CAAC,CAAC,OAAOI,UAAU,EAAE;QACnBrJ,QAAQ,CACN,2CAA2C,GACzCkJ,IAAI,GACJ,+BAA+B,EACjCG,UACF,CAAC;MACH;IACF,CAAC,CAAC,OAAOC,SAAS,EAAE;MAClB;MACA;MACA;MACA;MACA,IAAI7P,EAAE,CAAC8P,UAAU,CAACL,IAAI,CAAC,EAAE;QACvB1J,QAAQ,CACN,4BAA4B,GAAGO,MAAM,GAAG,MAAM,GAAGmJ,IAAI,GAAG,UAC1D,CAAC;QACDzP,EAAE,CAAC+P,UAAU,CAACN,IAAI,EAAEA,IAAI,GAAG,UAAU,CAAC;MACxC;MAEA1J,QAAQ,CAAC,eAAe,GAAG0J,IAAI,CAAC;MAChCZ,KAAK,CAACvI,MAAM,CAAC;IACf;EACF,CAAC;;EAED;AACF;AACA;EACE,MAAMuI,KAAK,GAAIvI,MAAM,IAAK;IACxB,IAAI0J,KAAK,EAAEC,MAAM,EAAEC,GAAG;;IAEtB;IACA,IAAI,CAAC1M,WAAW,EAAE;MAChB;IACF;;IAEA;IACA,IAAI;MACFwM,KAAK,GAAGhQ,EAAE,CAACmQ,SAAS,CAACxN,SAAS,CAAC;IACjC,CAAC,CAAC,OAAOyN,CAAC,EAAE;MACVrK,QAAQ,CAAC,2BAA2B,GAAGpD,SAAS,CAAC;MACjD,IAAI;QACF3C,EAAE,CAACqQ,SAAS,CAAC1N,SAAS,EAAEC,oBAAoB,CAAC;MAC/C,CAAC,CAAC,OAAOwN,CAAC,EAAE;QACV;QACA,IAAIA,CAAC,CAACE,IAAI,KAAK,QAAQ,EAAE,MAAMF,CAAC;MAClC;IACF;;IAEA;IACA,IAAI,CAACjP,OAAO,CAACmF,MAAM,CAAC,EAAE;MACpBnF,OAAO,CAACmF,MAAM,CAAC,GAAG,CAAC,CAAC;IACtB;;IAEA;IACA,IAAI;MACF2J,MAAM,GAAGP,kBAAkB,CAACpJ,MAAM,CAAC;MACnC4J,GAAG,GAAGD,MAAM,GAAG,MAAM;MACrBjQ,EAAE,CAACuQ,aAAa,CACdL,GAAG,EACHvM,MAAM,CAACqB,SAAS,CAAC7D,OAAO,CAACmF,MAAM,CAAC,EAAE,IAAI,EAAEvD,MAAM,CAAC,EAC/C,MACF,CAAC;MACDiN,KAAK,GAAGhQ,EAAE,CAACwQ,QAAQ,CAACN,GAAG,CAAC;MACxB,IAAIF,KAAK,CAACS,MAAM,CAAC,CAAC,EAAE;QAClBzQ,EAAE,CAAC+P,UAAU,CAACG,GAAG,EAAED,MAAM,CAAC;MAC5B,CAAC,MAAM;QACL1J,QAAQ,CACN,0CAA0C,GACxC2J,GAAG,GACH,MAAM,GACND,MAAM,GACN,wBACJ,CAAC;MACH;IACF,CAAC,CAAC,OAAOG,CAAC,EAAE;MACV7J,QAAQ,CACN,yCAAyC,GACvC2J,GAAG,GACH,MAAM,GACND,MAAM,GACN,wBAAwB,EAC1BG,CACF,CAAC;IACH;EACF,CAAC;;EAED;AACF;AACA;EACE,MAAMV,kBAAkB,GAAIpJ,MAAM,IAAK;IACrC;IACA,MAAMoK,GAAG,GAAG7N,SAAS,IAAI,OAAO;IAChC,MAAM8N,QAAQ,GAAGzQ,IAAI,CAAC0Q,SAAS,CAACjO,SAAS,GAAGP,OAAO,GAAGiB,MAAM,GAAGiD,MAAM,GAAGoK,GAAG,CAAC;IAC5E,MAAMG,UAAU,GAAG3Q,IAAI,CAAC0Q,SAAS,CAC/BjO,SAAS,GAAGP,OAAO,GAAGiB,MAAM,GAAGiD,MAAM,GAAG,KAC1C,CAAC;IACD;IACA,IAAI;MACF,IAAItG,EAAE,CAACwQ,QAAQ,CAACK,UAAU,CAAC,EAAE;QAC3B9K,QAAQ,CAAC,sBAAsB,GAAG8K,UAAU,CAAC;QAC7ChO,SAAS,GAAG,KAAK;QACjB,OAAOgO,UAAU;MACnB;IACF,CAAC,CAAC,OAAOT,CAAC,EAAE;MACVrK,QAAQ,CAAC,WAAW,GAAG4K,QAAQ,CAAC;IAClC;IACA,OAAOA,QAAQ;EACjB,CAAC;;EAED;AACF;AACA;EACE,MAAMpH,WAAW,GAAGA,CAAC/B,YAAY,EAAE1E,SAAS,KAAK;IAC/CA,SAAS,GAAGA,SAAS,IAAI,CAAC,CAAC;IAC3B,IAAIA,SAAS,CAAC0E,YAAY,CAAC,EAAE,OAAO1E,SAAS,CAAC0E,YAAY,CAAC;IAC3D,IAAIsJ,cAAc,GAAG,IAAI;IACzB,KAAK,MAAMC,GAAG,IAAIjO,SAAS,EAAE;MAC3B,IAAI0E,YAAY,CAACmD,KAAK,CAAC,IAAIpF,MAAM,CAAC,GAAG,GAAGwL,GAAG,CAAClQ,OAAO,CAAC,GAAG,EAAE,IAAI,CAAC,GAAG,GAAG,CAAC,CAAC,EAAE;QACtEiQ,cAAc,GAAGhO,SAAS,CAACiO,GAAG,CAAC;QAC/B;MACF;IACF;IACA,OAAOD,cAAc;EACvB,CAAC;;EAED;AACF;AACA;EACE,MAAM/K,QAAQ,GAAIW,GAAG,IAAK;IACxB1D,UAAU,CAAC0D,GAAG,CAAC;EACjB,CAAC;EAED,MAAMoD,OAAO,GAAIpD,GAAG,IAAK;IACvBxD,SAAS,CAACwD,GAAG,CAAC;EAChB,CAAC;EAED,MAAMH,QAAQ,GAAIG,GAAG,IAAK;IACxBzD,UAAU,CAACyD,GAAG,CAAC;EACjB,CAAC;;EAED;AACF;AACA;EACE,MAAM5B,UAAU,GAAGA,CAACwB,MAAM,EAAEuH,KAAK,KAAK;IACpC,OAAOA,KAAK;EACd,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAI7M,KAAK,EAAEF,IAAI,CAAC8C,SAAS,CAAC5C,KAAK,CAAC;EAEhC,OAAOF,IAAI;AACb,CAAC;AAEDkQ,MAAM,CAACC,OAAO,GAAGnQ,IAAI","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}